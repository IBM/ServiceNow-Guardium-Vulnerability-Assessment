<?xml version="1.0" encoding="UTF-8"?><record_update sys_domain="global" table="sysevent_script_action">
    <sysevent_script_action action="INSERT_OR_UPDATE">
        <active>true</active>
        <condition_script/>
        <description/>
        <event_name>x_ibmrt_gdpva.FixVulnerableItems</event_name>
        <name>EventHandler_FixVIT</name>
        <order>100</order>
        <script><![CDATA[/**
 * Repair Vulnerable Item and Detection first_found (SGA-25). 
 * Close orphan Vulnerable Item when test severity has changed (SGA-22).
 */
function fixFirstFoundDetection() {
    /**
     * first_found is empty when the result is "PASS" or "ERROR"
     * 
     * This code sets first_found to the last_found date to make it non-empty.
     */
    var sTableDET = 'sn_vul_detection';
    try {
        if (!gs.tableExists(sTableDET)) {
            gs.warn('Cannot complete. Table [' + sTableDET + '] does not exist.');
            return;
        }

        var total = 0;
        var gr = new GlideRecord(sTableDET);
        gr.addQuery('source', '=', 'IBM Guardium');
        gr.addNullQuery('first_found');
        gr.query();
        while (gr.next()) {
            gr.setValue('first_found', gr.getValue('last_found'));
            gr.update();
            if (gr.getValue('first_found')) {
                total++;
            }
        }

        gs.info("Number of Detections where first_found is updated: " + total);
    } catch (e) {
        gs.error('Error updating [' + sTableDET + ']: ' + e.message + '\n' + e.stack);
    }
}

function fixFirstFoundVulnerableItem() {
    /**
     * first_found is empty when the result is "PASS" or "ERROR"
     * 
     * If the detection changes from "ERROR" to "FAIL" and there is now a first_found value, ServiceNow code fails to update the Vulnerable Item.
     * This code sets first_found to the last_found date to make it non-empty.
     */
    var sTableDET = 'sn_vul_detection';
    var sTableLink = 'vulnerable_item';
    var sTableVIT = 'sn_vul_vulnerable_item';
    try {
        if (!gs.tableExists(sTableDET)) {
            gs.warn('Cannot complete. Table [' + sTableDET + '] does not exist.');
            return;
        }
        if (!gs.tableExists(sTableVIT)) {
            gs.warn('Cannot complete. Table [' + sTableVIT + '] does not exist.');
            return;
        }

        var total = 0;
        var gr = new GlideRecord(sTableDET);
        gr.addQuery('source', '=', 'IBM Guardium');
        gr.addNullQuery('vulnerable_item.first_found');
        gr.query();
        while (gr.next()) {
            // update linked item
            var vit = new GlideRecord(sTableVIT);
            if (gr.getValue(sTableLink) && vit.get(gr.getValue(sTableLink))) {
                total++;
                vit.setValue('first_found', gr.getValue('first_found'));
                vit.update();
            }
        }

        gs.info("Number of Vulnerable Items where first_found is updated: " + total);
    } catch (e) {
        gs.error('Error updating [' + sTableVIT + ']: ' + e.message + '\n' + e.stack);
    }
}

function fixVulnerableItemWithPassPreference() {
    // find and close open detections and open vulnerable items with passing scores
    var sTableDET = 'sn_vul_detection';
    var sTableVIT = 'sn_vul_vulnerable_item';
    var sTableTestDef = 'sn_vul_third_party_entry';
    var sTestResult = 'not applicable for the db version';

    this.preferences = GuardiumAPI.getPreferences(true);
    this.passed_scores =
        (this.preferences.getValue('test_pass_status') || '').trim().split(',');
    for (var p = 0; p < this.passed_scores.length; p++) {
        var arrClosed = [];

        // skip the PASS keys
        var key = this.passed_scores[p];
        if (key.startsWith("PASS")) {
            continue;
        }

        // get the translated text
        var grChoice = new GlideRecord("sys_choice");
        grChoice.addQuery('name', '=', 'x_ibmrt_gdpva_preference');
        grChoice.addQuery('value', '=', key);
        grChoice.setLimit(1);
        grChoice.query();
        if (grChoice.next()) {
            var errorStatus = grChoice.getValue('label') || key;

            // ----------------------------------------------
            // find and close detections and vulnerable items
            // ----------------------------------------------
            var gr = new GlideRecord(sTableDET);
            gr.addQuery('source', '=', 'IBM Guardium');
            gr.addQuery('status', '=', '0'); // open
            gr.addQuery('source_status', '=', errorStatus);
            gr.query();
            while (gr.next()) {

                // close the detection
                gr.setValue('status', 1); // closed
                gr.setValue(
                    'solution_summary',
                    'IBM Guardium setting closes this error status: ' + errorStatus
                );
                gr.update();

                // close the vulnerable item
                var grVIT = new GlideRecord(sTableVIT);
                if (
                    grVIT.get(gr.getValue('vulnerable_item')) &&
                    '1' == grVIT.getValue('state').toString() // VIT state is open
                ) {
                    grVIT.setValue('active', false);
                    grVIT.setValue('state', 3); // closed
                    grVIT.setValue('substate', 5); // cancelled
                    grVIT.setValue(
                        'close_notes',
                        'IBM Guardium setting closes this error status: ' + errorStatus
                    );
                    grVIT.update();
                    arrClosed.push(grVIT.getValue('number'));
                }

            }
        }

        gs.info(
            'Vulnerable items closed due to passing test score:' +
            '\nSource status: "' + errorStatus + '"' +
            '\nTotal closed: ' + arrClosed.length +
            '\nItems: ' + arrClosed.join(', ')
        );
    }

}

function fixOrphanTestResults() {
    /**
     * If the test severity is changed in the Guardium assessment, a new test definition is created in ServiceNow since risk calculators use the severity in calculation of the Vulnerable Item risk score.
     * Because the test result references a new test definition, a new Vulnerable Item is created, thus causing what might be considered "duplicate" Vulnerable Items.
     * This code will close older Vulnerable Items where the severity has been updated.
     */
    var sTableDET = 'sn_vul_detection';
    var sTableVIT = 'sn_vul_vulnerable_item';
    var sTableTestDef = 'sn_vul_third_party_entry';
    var sTableGuardium = 'x_ibmrt_gdpva_test_definition';
    var sTableCCResult = 'sn_vulc_result';
    try {
        if (!gs.tableExists(sTableDET)) {
            gs.warn('Cannot complete. Table [' + sTableDET + '] does not exist.');
            return;
        }
        if (!gs.tableExists(sTableVIT)) {
            gs.warn('Cannot complete. Table [' + sTableVIT + '] does not exist.');
            return;
        }
        if (!gs.tableExists(sTableTestDef)) {
            gs.warn('Cannot complete. Table [' + sTableTestDef + '] does not exist.');
            return;
        }


        var agg = new GlideAggregate(sTableGuardium);
        agg.groupBy('short_description'); // test ID
        agg.addAggregate('COUNT', 'short_description');
        agg.addAggregate('GROUP_CONCAT_DISTINCT', 'servicenow_id');
        agg.query();
        while (agg.next()) {
            // if count > 1,a test with multiple severities has been found
            if (agg.getAggregate('COUNT', 'short_description') > 1) {
                var testList = agg.getAggregate('GROUP_CONCAT_DISTINCT', 'servicenow_id');
                var testDescription =
                    agg.getValue('short_description') + ' | ' + testList;

                // Split test list into an array
                var arrTestID = (testList || '').split(',');

                // Close related vulnerable items
                var arrClosed = closeVulnerableItems(arrTestID);
                gs.info(
                    'Multiple severities found for test: ' +
                    testDescription +
                    '\nNumber of VIT test results closed: ' + arrClosed.length +
                    '\n' + arrClosed.join(', ')
                );

                try {
                    if (gs.tableExists(sTableCCResult)) {
                        // Close related Configuration Compliance results 
                        var arrClosedCC = closeCCResults(arrTestID);
                        gs.info(
                            'Multiple severities found for test: ' +
                            testDescription +
                            '\nNumber of CC test results closed: ' + arrClosedCC.length +
                            '\n' + arrClosedCC.join(', ')
                        );
                    }
                } catch (ecc) {}
            }
        }
    } catch (e) {
        gs.error('Error updating [' + sTableVIT + ']: ' + e.message + '\n' + e.stack);
    }
}

function getTestSysID(tableName, fieldName, testID) {
    var gr = new GlideRecord(tableName);
    gr.addQuery(fieldName, '=', testID);
    gr.query();
    if (gr.next()) {
        return gr.getUniqueValue();
    }
    return '';
}

function closeVulnerableItems(arrTestID) {
    var arrClosed = [];
    var sTableDET = 'sn_vul_detection'; // test result
    var sTableVIT = 'sn_vul_vulnerable_item'; // task
    var sTableTestDef = 'sn_vul_third_party_entry'; // test definition

    // convert servicenow_id to sys_id
    var arrSysID = [];
    for (var i = 0; i < arrTestID.length; i++) {
        var sysID = getTestSysID(sTableTestDef, 'id', arrTestID[i]);
        if (sysID) arrSysID.push('vulnerability=' + sysID);
    }
    if (0 == arrSysID.length) return arrClosed;

    // close open VIT
    var gr = new GlideRecord(sTableDET);
    gr.addQuery('source', '=', 'IBM Guardium');
    gr.addEncodedQuery(arrSysID.join('^OR'));
    gr.orderByDesc('cmdb_ci');
    gr.orderByDesc('sys_created_on'); // newest first
    gr.orderByDesc('number'); // just in case of a tie on creation date
    gr.query();
    var cmdb_ci = '';
    var vit = '';
    var det = '';
    while (gr.next()) {
        if (cmdb_ci != gr.getValue('cmdb_ci')) {
            // save info about the newest test result
            cmdb_ci = gr.getValue('cmdb_ci');
            det = gr.getValue('number');
            vit = gr.getDisplayValue('vulnerable_item') || '';
            det = det + (vit ? ' | ' + vit : '');
        } else {
            // if the detection is open, close it
            if ('0' == gr.getValue('status').toString()) {
                gr.setValue('status', 1); // closed
                gr.setValue(
                    'solution_summary',
                    'Duplicate test result with updated severity: ' + det
                );
                gr.update();
            }

            // if the vulnerable item is open, close it
            var grVIT = new GlideRecord(sTableVIT);
            if (
                grVIT.get(gr.getValue('vulnerable_item')) &&
                '1' == grVIT.getValue('state').toString() // VIT state is open
            ) {
                grVIT.setValue('active', false);
                grVIT.setValue('state', 3); // closed
                grVIT.setValue('substate', 5); // cancelled
                grVIT.setValue(
                    'close_notes',
                    'Duplicate test result with updated severity: ' + det
                );
                grVIT.update();
                arrClosed.push(grVIT.getValue('number'));
            }
        }
    }
    return arrClosed;
}

function closeCCResults(arrTestID) {
    var arrClosed = [];
    var sTableCCResult = 'sn_vulc_result'; // test result
    var sTableTestDef = 'sn_vulc_test'; // test definition
    var sTableCCGroup = 'sn_vulc_result_group'; // task

    // convert to sys_id
    var arrSysID = [];
    for (var i = 0; i < arrTestID.length; i++) {
        var sysID = getTestSysID(sTableTestDef, 'source_id', arrTestID[i]);
        if (sysID) arrSysID.push('control=' + sysID);
    }
    if (0 == arrSysID.length) return arrClosed;

    // close open VIT
    var gr = new GlideRecord(sTableCCResult);
    gr.addQuery('source', '=', 'IBM Guardium');
    gr.addEncodedQuery(arrSysID.join('^OR'));
    gr.orderByDesc('cmdb_ci');
    gr.orderByDesc('sys_created_on'); // newest first
    gr.orderByDesc('number'); // just in case of a tie on creation date
    gr.query();
    var cmdb_ci = '';
    var vit = '';
    while (gr.next()) {
        if (cmdb_ci != gr.getValue('cmdb_ci')) {
            // save info about the newest test result
            cmdb_ci = gr.getValue('cmdb_ci');
            vit = gr.getValue('number');
        } else {
            // if the ticket is open, close it
            if ('1' == gr.getValue('state').toString()) { // CC state is open
                gr.setValue('state', 3); // closed
                gr.setValue('resolution', 3); // cancelled
                gr.setValue(
                    'resolution_reason',
                    'Duplicate test result with updated severity: ' + vit
                );
                gr.update();
                arrClosed.push(gr.getValue('number'));
            }
        }
    }
    return arrClosed;
}

fixFirstFoundDetection();
fixFirstFoundVulnerableItem();
fixOrphanTestResults();
fixVulnerableItemWithPassPreference();]]></script>
        <synchronous>false</synchronous>
        <sys_class_name>sysevent_script_action</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-07-17 16:54:37</sys_created_on>
        <sys_domain>global</sys_domain>
        <sys_domain_path>/</sys_domain_path>
        <sys_id>176fea0c1be30250eadec956624bcb45</sys_id>
        <sys_mod_count>2</sys_mod_count>
        <sys_name>EventHandler_FixVIT</sys_name>
        <sys_overrides/>
        <sys_package display_value="IBM Guardium Data Protection" source="x_ibmrt_gdpva">400d30552fa0111049572f2ef699b65a</sys_package>
        <sys_policy/>
        <sys_scope display_value="IBM Guardium Data Protection">400d30552fa0111049572f2ef699b65a</sys_scope>
        <sys_update_name>sysevent_script_action_176fea0c1be30250eadec956624bcb45</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-07-17 16:59:51</sys_updated_on>
    </sysevent_script_action>
</record_update>
