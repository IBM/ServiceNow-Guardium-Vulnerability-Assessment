<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_ibmrt_gdpva.GuardiumProcessorVulnerabilityTest</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>IBM Guardium processor script for adding third party vulnerability entries</description>
        <name>GuardiumProcessorVulnerabilityTest</name>
        <script><![CDATA[var GuardiumProcessorVulnerabilityTest = Class.create();

GuardiumProcessorVulnerabilityTest.VUL_ENTRY_FIELDS = {
    id: false,
    category: false, // Category Name, Test Type
    product: false, // Database Type
    vendor: false, // User defined ref 1, User defined ref 2
    solution: false, // User defined notes
    name: false,
    source_severity: false,
    stig_severity: false,
    summary: false,
    source: false,
    source_instance: false,
    last_modified: false,
    cve_id: false,
    cves_list: false,

    access_complexity: true,
    access_vector: true,
    active_exploit: true,
    active_nd_container_vis: true,
    active_nd_vis: true,
    authentication: true,
    availability_impact: true,
    collateral_damage_potential: true,
    confidentiality_impact: true,
    count_active_container_vi: true,
    count_active_vi: true,
    cwe_id: true,
    date_published: true,
    easily_exploitable: true,
    exploit: true,
    exploit_attack_vector: true,
    exploit_skill_level: true,
    exploitability: true,
    integrity_impact: true,
    malware_kit: true,
    max_risk_score: true,
    normalized_severity: true,
    percent_container_vi_complete: true,
    percent_nd_container_vi_complete: true,
    percent_nd_vi_complete: true,
    percent_vi_complete: true,
    preferred_solution: false,
    public_exploit: true,
    recalculate_flag: true,
    references: true,
    remediation_level: true,
    remediation_type: true,
    report_confidence: true,
    risk_rating: true,
    risk_score: true,
    score: true,
    score_generated: true,
    security_requirements_ar: true,
    security_requirements_cr: true,
    security_requirements_ir: true,
    source_pci: true,
    source_pci_severity: true,
    source_risk_rating: true,
    source_risk_score: true,
    target_distribution: true,
    temporal_score: true,
    threat: true,
    total_container_vis: true,
    total_nd_container_vis: true,
    total_nd_vis: true,
    total_vis: true,
    v2_exploitability_subscore: true,
    v2_impact_subscore: true,
    v2_vector_string: true,
    v3_attack_complexity: true,
    v3_attack_vector: true,
    v3_availability_impact: true,
    v3_base_score: true,
    v3_confidentiality_impact: true,
    v3_exploit_code_maturity: true,
    v3_exploitability_subscore: true,
    v3_impact_subscore: true,
    v3_integrity_impact: true,
    v3_privileges_required: true,
    v3_remediation_level: true,
    v3_report_confidence: true,
    v3_scope_change: true,
    v3_temporal_score: true,
    v3_user_interaction: true,
    v3_vector_string: true
};

GuardiumProcessorVulnerabilityTest.CVE_REG_EX = /[CEVW]+[- ][0-9]+[- ][0-9]*/g;

GuardiumProcessorVulnerabilityTest.prototype =
    Object.extendsObject(GuardiumProcessorBase, {

        beforeProcessReport: function(reportData) {
            this.sn_vul_tpv = new sn_vul.ThirdPartyVulnerability(
                GuardiumAPI.TITLE,
                this.integrationGr.sys_id,
                this.integrationRunGr.sys_id
            );

            try {
                this.sn_vulc_ct = new sn_vulc.ComplianceTest(GuardiumAPI.TITLE);
            } catch (er) {}

            this.failed_types = ',' + (this.preferences.getValue('test_failure_type') || '') + ',';
            this.user_def_sev = gs.getProperty('x_ibmrt_gdpva.user_defined.severity', '1');

            var ccCheckbox = this.preferences.getValue('ignore_config_compliance') || '';
            this.allowConfigCompliance = this.sn_vulc_ct && GuardiumAPI.isTrue(ccCheckbox); // reverse logic
        },

        beforeCM: function(cm, data) {
            if (!this.gAPI) {
                this.gAPI = new GuardiumAPI(GuardiumAPI.getGlideRecordCM(cm.sys_id, true));
                //this.gAPI.authenticate();
            }
        },

        processEntry: function(datum, cm) {
            datum = this.createOrUpdateDefinition(datum, cm);

            //- Add or update Compliance Test -//
            var ct_rec = this.transformCT(datum, cm);
            if (ct_rec) {
                // create compliance test
                var ct_entry = this.sn_vulc_ct.createOrUpdateTest(ct_rec);
                if (ct_entry.inserted) {
                    this.inserted_cc++;
                } else
                if (ct_entry.updated) {
                    this.updated_cc++;
                } else {
                    this.skipped_cc++;
                }
                return ct_entry.sys_id;
            }

            //- Add or update Third Party Vulnerability Test -//
            var vt_rec = this.transformVT(datum, cm);
            if (vt_rec) {

                // let script library find duplicate
                var vt_entry = this.sn_vul_tpv.createOrUpdateVulnerability(vt_rec);

                // if nothing created or updated, then create manually
                var sn_rec = new GlideRecord('sn_vul_third_party_entry');
                if (!vt_entry.sys_id || !sn_rec.get(vt_entry.sys_id)) {
                    sn_rec.initialize();
                }

                // Ensure fields are set!!
                var doUpdate = false;
                for (var p in GuardiumProcessorVulnerabilityTest.VUL_ENTRY_FIELDS) {
                    if (vt_rec[p] && vt_rec[p] != sn_rec.getValue(p)) {
                        sn_rec.setValue(p, vt_rec[p]);
                        doUpdate = true;
                    }
                }
                if (vt_entry.insert || !vt_entry.sys_id) {
                    // Some ServiceNow fields like normalized_severity cannot be set during insert.  Try double update.
                    sn_rec.update();
                }

                // Make sure severity fields are set!!
                if (vt_entry.insert || !vt_entry.sys_id ||
                    !sn_rec.getValue("normalized_severity") || '5' == ('' + sn_rec.getValue("normalized_severity"))) {
                    sn_rec.setValue("normalized_severity", vt_rec.source_severity);
                    doUpdate = true;
                }
                if (vt_entry.insert || !vt_entry.sys_id ||
                    !sn_rec.getValue("source_risk_rating") || '5' == ('' + sn_rec.getValue("source_risk_rating"))) {
                    sn_rec.setValue("source_risk_rating", vt_rec.source_severity);
                    doUpdate = true;
                }

                // Insert or Update
                if (vt_entry.insert || !vt_entry.sys_id) {
                    // update
                    vt_entry.sys_id = sn_rec.update();
                    this.inserted_vi++;
                } else
                if (doUpdate) {
                    vt_entry.sys_id = sn_rec.update();
                    this.updated_vi++;
                } else {
                    this.skipped_vi++;
                }

                // Create a link between Third-party and NVD
                try {
                    var cve_array = vt_rec.cves_list.split(',');
                    for (var c = 0; c < cve_array.length; c++) {
                        var gr_m2m = new GlideRecord('sn_vul_m2m_entry_cve');
                        gr_m2m.addQuery('sn_vul_entry', '=', vt_entry.sys_id);
                        gr_m2m.addQuery('sn_vul_nvd_entry', '=', cve_array[c]);
                        gr_m2m.setLimit(1);
                        gr_m2m.query();
                        if (!gr_m2m.hasNext()) {
                            gr_m2m.initialize();
                            gr_m2m.setValue('sn_vul_entry', vt_entry.sys_id);
                            gr_m2m.setValue('sn_vul_nvd_entry', cve_array[c]);
                            gr_m2m.insert();
                        }
                    }
                } catch (e) {}

                // Make sure ref data is called
                try {
                    this.sn_vul_tpv._handleReferenceData(
                        vt_entry.sys_id, vt_entry.id, vt_rec.referenceData
                    );
                } catch (e) {}

                return vt_entry.sys_id;
            }
            return '';
        },

        generateThirdPartyID: function(datum, cm, useSeverity) {
            var testID = this.offsetTestID(this.normalizeId(datum['Test ID'] || this.generateTestID()), cm);
            var asID = ['Guardium', testID];
            if (useSeverity) {
                asID.push(this.convertSeverity(datum['Severity'] || 'EMPTY'));
            }
            return asID.join('-');
        },

        normalizeId: function(guardTestID) {
            var asParts = (guardTestID || '').split('-');
            var nSegment = asParts.length > 1 ? 1 : 0;
            var numID = (asParts[nSegment]) - 0;
            var s = '00000' + numID;
            return numID < 100000 ? s.substring(s.length - 5) : ('' + numID);
        },

        generateTestID: function() {
            var gr = new GlideRecord('x_ibmrt_gdpva_test_definition');
            gr.orderByDesc('test_id');
            gr.setLimit(1);
            gr.query();
            if (gr.next()) {
                try {
                    var num = gr.getValue('test_id') - 0;
                    if (num < 50000) {
                        num = 100000 - num;
                    } else {
                        num = num - 1;
                    }
                    return '' + num; // stringify					
                } catch (e) {}
            }
            return '99999'; // dummy value in case there are no entries
        },

        offsetTestID: function(guardTestID, cm) {
            if (!guardTestID) return '';
            var asParts = (guardTestID || '').split('-');
            var nSegment = asParts.length > 1 ? 1 : 0;
            var testID = asParts[nSegment];
            var numID = testID - 0;
            if (numID >= 20000) {
                // use CM number as an offset
                var numCM = 1;
                try {
                    numCM = parseInt(cm.number.substr(3));
                } catch (e) {}
                if (numCM > 1) testID = numCM + '-' + testID;
            }
            return testID;
        },

        getTestDefinitionFields: function(datum, cm) {
            if (!this.testDefinitionFields) {
                this.testDefinitionFields = [{
                        fld: 'short_description',
                        key: 'Test ID',
                        size: 40,
                        def: ''
                    },
                    {
                        fld: 'timestamp',
                        key: 'Timestamp',
                        def: '', // timestamp
                        override: true
                    },
                    {
                        fld: 'test_description',
                        key: 'Test Description',
                        size: 1000,
                        def: ''
                    },
                    {
                        fld: 'test_type',
                        key: 'Test Type',
                        size: 255,
                        def: ''
                    },
                    {
                        fld: 'datasource_type',
                        key: 'Datasource Type',
                        size: 255,
                        def: ''
                    },
                    {
                        fld: 'external_reference',
                        key: 'External Reference',
                        size: 255,
                        def: ''
                    },
                    {
                        fld: 'stig_reference',
                        key: 'STIG Reference',
                        size: 255,
                        def: ''
                    },
                    {
                        fld: 'stig_severity',
                        key: 'STIG Severity',
                        size: 40,
                        def: ''
                    },
                    {
                        fld: 'severity',
                        key: 'Severity',
                        size: 40,
                        def: ''
                    },
                    {
                        fld: 'category_name',
                        key: 'Category Name',
                        size: 40,
                        def: ''
                    },
                    {
                        fld: 'user_defined_one',
                        key: 'User defined reference one',
                        size: 255,
                        def: ''
                    },
                    {
                        fld: 'user_defined_two',
                        key: 'User defined reference two',
                        size: 255,
                        def: ''
                    },
                    {
                        fld: 'user_defined_notes',
                        key: 'User defined notes',
                        size: 1000,
                        def: ''
                    },
                    {
                        fld: 'description',
                        key: 'Short Description',
                        size: 2000,
                        def: ''
                    },
                    {
                        fld: 'servicenow_id',
                        key: 'ServiceNow ID',
                        size: 255,
                        def: ''
                    }
                ];
            }

            var testID = this.offsetTestID(this.generateTestID(), cm);
            var timestamp = datum['Timestamp'] || '';
            this.testDefinitionFields[0].def = testID;
            this.testDefinitionFields[1].def = this.gAPI.adjustTimeFromGuardium(timestamp);

            return this.testDefinitionFields;
        },

        createOrUpdateDefinition: function(datum, cm, useExisting) {
            try {
                var testName = (datum['Test Description'] || '').substring(0, 1000);
                var dsType = datum['Datasource Type'] || 'EMPTY';
                var dsSev = (datum['Severity'] || 'EMPTY').toUpperCase();
                var matchSev = false;
                var matchType = false;
                var forceInsert = 'INSERT' == datum['Test SysID'];
                datum['Test SysID'] = '';
                datum['Test ID'] = this.offsetTestID(datum['Test ID'], cm);

                var sys_id = '';
                var gr = new GlideRecord('x_ibmrt_gdpva_test_definition');
                if (!forceInsert) {
                    if (datum['Test ID']) {
                        // this was test_id=datum['Test ID'] but there is a unique index on test_id
                        //  and that causes a problem when we need to define two tests with 
                        //  the same id due to an assessment test "tuning" of severity
                        gr.addQuery('short_description', '=', datum['Test ID']);
                    } else {
                        gr.addQuery('test_description', '=', testName);
                    }
                    gr.query();
                    while (gr.next()) {
                        if (!sys_id) {
                            sys_id = gr.getUniqueValue();
                        }
                        if (dsType == gr.getValue('datasource_type')) {
                            matchType = true;
                            sys_id = gr.getUniqueValue();
                            if (dsSev == 'EMPTY' || dsSev == gr.getValue('severity')) {
                                matchSev = true;
                                break;
                            }
                        }
                    }
                }
                if (!sys_id || !gr.get(sys_id)) {
                    sys_id = '';
                    gr.initialize();
                    useExisting = false;
                }
                if (!datum['Test ID']) {
                    datum['Test ID'] = gr.getValue('short_description') || this.offsetTestID(this.generateTestID(), cm);
                }

                // Set all other fields
                var doUpdate = false;
                var tdFields = this.getTestDefinitionFields(datum, cm);
                for (var i = 0; i < tdFields.length; i++) {
                    var key = tdFields[i].key;
                    var fld = tdFields[i].fld;
                    var size = tdFields[i].size;
                    var def = tdFields[i].def;
                    var val = tdFields[i].override ? def : datum[key] || def;
                    if (useExisting) {
                        datum[key] = gr.getValue(fld) || val;
                    } else {
                        datum[key] = size ? val.substring(0, size) : val;
                        // update SN record if there are updates in the Guardium record
                        if ('timestamp' != fld && datum[key] && datum[key] != gr.getValue(fld)) {
                            gr.setValue(fld, datum[key]);
                            doUpdate = true;
                        }
                    }
                }

                // return a normalized test id
                if (!datum['ServiceNow ID']) {
                    datum['ServiceNow ID'] = this.generateThirdPartyID(datum, cm);
                    gr.setValue('servicenow_id', datum['ServiceNow ID']);
                    gr.setValue('timestamp', datum['Timestamp']);
                }

                // create a new test definition if Severity does not match
                if (useExisting && !matchSev) {
                    // customer may have adjusted the severity of the test definition by tuning the test
                    datum['Severity'] = dsSev;
                    datum['ServiceNow ID'] = this.generateThirdPartyID(datum, cm, true);

                    var gr_new = new GlideRecord('x_ibmrt_gdpva_test_definition');
                    gr_new.initialize();
                    for (var j = 0; j < tdFields.length; j++) {
                        if ('timestamp' == tdFields[j].fld) {
                            gr_new.setValue(tdFields[j].fld, (new GlideDateTime()).toString());
                        } else {
                            var v = datum[tdFields[j].key];
                            if (tdFields[j].size) v = v.substring(0, tdFields[j].size);
                            gr_new.setValue(tdFields[j].fld, v);
                        }
                    }
                    datum['Test SysID'] = gr_new.insert();
                    if (!datum['Test SysID']) {
                        GuardiumLog.error('', this.type, new Error(gr_new.getLastErrorMessage()));
                    }
                    return datum;
                }

                var action = 'SKIP';
                if (!sys_id) {
                    action = 'INSERT';
                    sys_id = gr.insert();
                } else {
                    if (doUpdate) {
                        action = 'UPDATE';
                        sys_id = gr.update();
                    }
                }
                if (!sys_id) {
                    throw new Error(action + " | " + gr.getLastErrorMessage());
                }
                datum['Test SysID'] = sys_id;
            } catch (e) {
                GuardiumLog.error('Error processing: ' + datum['Test Description'], this.type, e);
            }
            return datum;
        },

        transformCT: function(datum) {
            // create test def if compliance is installed and this is not CVE
            if (this.allowConfigCompliance && this.failed_types.indexOf(',' + datum['Test Type'] + ',') < 0) {
                var test_date = this.gAPI.adjustTimeFromGuardium(datum['Timestamp']);
                var test_name_brief = datum['ServiceNow ID'] || this.generateThirdPartyID(datum, cm);
                var test_name = (
                    datum['Test Description'] ||
                    datum["External Reference"] ||
                    datum["STIG Reference"] ||
                    test_name_brief
                ).substring(0, 512);
                var test_id = test_name_brief.substring(0, 512);

                var rec = this.sn_vulc_ct.newTest(test_id);
                rec.source = GuardiumAPI.TITLE;
                rec.source_id = test_id;
                rec.source_category = this.getLabel(datum['Category Name']);
                rec.source_sub_category = this.getLabel(datum['Test Type']);
                rec.short_description = [datum['Datasource Type'] || 'EMPTY', test_name].join(' - ');
                rec.description = [
                    "* Description:\n" + (datum['Short Description'] || '').trim(),
                    "* Test Reference 1:\n" + (datum['User defined reference one'] || '').trim(),
                    "* Test Reference 2:\n" + (datum['User defined reference two'] || '').trim(),
                    "* Test Notes:\n" + (datum['User defined notes'] || '').trim()
                ].join('\n\n');
                var sev = this.convertSeverity((
                    '1' == this.user_def_sev ? datum['User defined reference one'] :
                    '2' == this.user_def_sev ? datum['User defined reference two'] :
                    '') || datum['Severity']);
                if (99 == sev) {
                    // user defined value is not a priority value
                    rec.source_criticality = this.getLabel(datum['Severity']);
                } else {
                    rec.source_criticality = this.getLabel((
                        '1' == this.user_def_sev ? datum['User defined reference one'] :
                        '2' == this.user_def_sev ? datum['User defined reference two'] :
                        '') || datum['Severity']);
                }
                rec.source_created = test_date;
                rec.source_udpated = this.dt_now;

                return rec;
            }
            return null;
        },

        transformVT: function(datum) {
            // DO NOT create test def if compliance is installed and this is not CVE
            if (this.allowConfigCompliance && this.failed_types.indexOf(',' + datum['Test Type'] + ',') < 0) {
                return null;
            }
            var test_date = this.gAPI.adjustTimeFromGuardium(datum['Timestamp']);
            var test_name_brief = datum['ServiceNow ID'] || this.generateThirdPartyID(datum, cm);
            var test_name = (
                datum['Test Description'] ||
                datum["External Reference"] ||
                datum["STIG Reference"] ||
                test_name_brief
            ).substring(0, 512);
            var test_id = test_name_brief.substring(0, 255);

            var rec = this.sn_vul_tpv.newVulnerability(test_id); // limit ID to 255 chars

            // Add external and NVD data
            rec = this.addExternalData(datum, rec);

            // Category, Test Type
            rec.category = [this.getLabel(datum['Category Name']),
                this.getLabel(datum['Test Type'])
            ].join(', ');

            // solution summary
            var val = label = "";
            var arrSolution = [];
            var arrFields = ['Test name', 'Remediation', 'User defined reference one', 'User defined reference two', 'User defined notes'];
            datum['Test name'] = test_name;
            datum['Remediation'] = 'See Vulnerable Item > Remediation tab for the recommended solution';
            for (var f = 0; f < arrFields.length; f++) {
                val = (datum[arrFields[f]] || '').trim();
                label = '<h4>' + arrFields[f] + '</h4>';
                if ('User defined notes' == arrFields[f]) {
                    // do not replace if HTML
                    if (false == (val.indexOf('<') >= 0 && val.indexOf('>') > 0)) {
                        val = val.replaceAll('\n', '<br />');
                    } else {
                        label = '';
                    }
                }
                if (val) {
                    arrSolution.push(label + val);
                }
            }
            rec.solution = arrSolution.join('<br />');

            // Threat
            var arrThreat = [];
            var arrSTIG = ['STIG Reference', 'STIG Severity', 'STIG IAControls', 'STIG SRG'];
            for (var f = 0; f < arrSTIG.length; f++) {
                val = (datum[arrSTIG[f]] || '').trim();
                label = '<h4>' + arrSTIG[f] + '</h4>';
                if (val) {
                    arrThreat.push(label + val);
                }
            }
            rec.threat = arrThreat.join('<br />');

            rec.name = test_name;
            var sev = this.convertSeverity((
                '1' == this.user_def_sev ? datum['User defined reference one'] :
                '2' == this.user_def_sev ? datum['User defined reference two'] :
                '') || datum['Severity']);
            rec.source_severity =
                (99 == sev ? this.convertSeverity(datum['Severity']) : sev);
            rec.stig_severity = this.getLabel(datum['STIG Severity'] || datum['Severity']);

            rec.product = datum['Datasource Type'] || 'EMPTY';
            rec.summary = datum['Short Description'];
            rec.source = GuardiumAPI.TITLE;
            rec.source_instance = this.integrationGr.sys_id;
            rec.date_published = test_date;
            rec.last_modified = test_date;
            rec.access_vector = datum['CVSS Access Vector'] || ''; // v2 vector
            rec.score = (datum['CVSS Score'] || '0') - 0; // v2 score: convert to number

            return rec;
        },

        addExternalData: function(datum, rec) {
            // Find all references to CVE and CWE
            var keys = {};
            var match;
            var asValues = [
                datum["External Reference"] || datum["STIG Reference"] || datum['Test Description'] || '',
                datum['Category Name'] || '',
                datum['Test Type'] || '',
                datum['Short Description'] || ''
            ];
            for (var v = 0; v < asValues.length; v++) {
                var value = asValues[v];
                if (value.indexOf('CVE') == 0 || value.indexOf('CWE') == 0) {
                    match = value.match(GuardiumProcessorVulnerabilityTest.CVE_REG_EX);
                    if (match && match.length > 0) {
                        for (var m = 0; m < match.length; m++) {
                            var k = match[m].replaceAll(' ', '-');
                            if (!keys[k]) keys[k] = true;
                        }
                    }
                }
            }

            if (!rec.cves) rec.cves = [];
            if (!rec.referenceData) rec.referenceData = [];
            if (!rec.cve_array) rec.cve_array = [];

            // Add link to Guardium Test Def
            rec.referenceData.push({
                name: GuardiumAPI.TITLE,
                description: 'Test ID ' + datum['Test ID'],
                url: '/now/nav/ui/classic/params/target/x_ibmrt_gdpva_test_definition.do%3Fsys_id%3D' + datum['Test SysID']
            });

            var bFirst = true;
            for (var key in keys) {
                if (bFirst) {
                    rec = this.copyNVD(key, rec);
                    bFirst = false;
                } else {
                    rec = this.appendNVD(key, rec);
                }
                if (0 == key.indexOf('CVE')) {
                    rec.cves.push({
                        id: key,
                        url: 'https://nvd.nist.gov/vuln/detail/' + key
                    });
                    rec.referenceData.push({
                        name: 'NIST',
                        description: rec.product,
                        url: 'https://nvd.nist.gov/vuln/detail/' + key
                    });
                } else
                if (0 == key.indexOf('CWE')) {
                    var a = key.split('-');
                    if (a.length > 1) {
                        rec.cves.push({
                            id: key,
                            url: 'https://cwe.mitre.org/data/definitions/' + a[1] + '.html'
                        });
                        rec.referenceData.push({
                            name: 'MITRE',
                            description: rec.product,
                            url: 'https://cwe.mitre.org/data/definitions/' + a[1] + '.html'
                        });
                    }
                }
            }

            rec.cves_list = rec.cve_array.join(',') || rec.cve_id || '';
            try {
                delete rec.cve_array;
            } catch (e) {}

            return rec;
        },

        copyNVD: function(key, rec) {
            if (key) {
                try {
                    var gr_nvd = new GlideRecord('sn_vul_nvd_entry');
                    gr_nvd.addQuery('id', '=', key);
                    gr_nvd.setLimit(1);
                    gr_nvd.query();
                    if (gr_nvd.next()) {
                        GuardiumLog.debug('NVD copy to Guardium: ' + key, this.type);
                        for (var f in GuardiumProcessorVulnerabilityTest.VUL_ENTRY_FIELDS) {
                            if (GuardiumProcessorVulnerabilityTest.VUL_ENTRY_FIELDS[f] && gr_nvd.getValue(f)) {
                                rec[f] = gr_nvd.getValue(f);
                            }
                        }
                        rec.cve_id = gr_nvd.getUniqueValue();
                        rec.cve_array.push(gr_nvd.getUniqueValue());
                    } else {
                        GuardiumLog.debug('NVD not found: ' + key, this.type);
                    }
                } catch (e) {
                    GuardiumLog.error('', this.type, e);
                }
            }
            return rec;
        },

        appendNVD: function(key, rec) {
            if (key) {
                try {
                    var gr_nvd = new GlideRecord('sn_vul_nvd_entry');
                    gr_nvd.addQuery('id', '=', key);
                    gr_nvd.orderByDesc('sys_updated_on'); // get most recent
                    gr_nvd.setLimit(1);
                    gr_nvd.query();
                    if (gr_nvd.next()) {
                        rec.cve_array.push(gr_nvd.getUniqueValue());
                    }
                } catch (e) {}
            }
            return rec;
        },

        convertSeverity: function(grd_severity) {
            if (!grd_severity) return '';
            // CRITICAL,MAJOR,MINOR,INFO,CAUTION,CAT I,CAT II,CAT III
            switch (grd_severity.toUpperCase()) {
                case 'CRITICAL':
                    return 1;
                case 'MAJOR':
                case 'CAT I':
                    return 2;
                case 'MINOR':
                case 'CAT II':
                    return 3;
                case 'CAUTION':
                case 'CAT III':
                    return 4;
                case 'INFO':
                    return 5;
            }
            return 99;
        },

        type: 'GuardiumProcessorVulnerabilityTest'
    });]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-01-14 16:22:58</sys_created_on>
        <sys_id>72716ae987094950387c64280cbb35b3</sys_id>
        <sys_mod_count>189</sys_mod_count>
        <sys_name>GuardiumProcessorVulnerabilityTest</sys_name>
        <sys_package display_value="IBM Guardium Data Protection" source="x_ibmrt_gdpva">400d30552fa0111049572f2ef699b65a</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="IBM Guardium Data Protection">400d30552fa0111049572f2ef699b65a</sys_scope>
        <sys_update_name>sys_script_include_72716ae987094950387c64280cbb35b3</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-06-10 11:33:48</sys_updated_on>
    </sys_script_include>
</record_update>
