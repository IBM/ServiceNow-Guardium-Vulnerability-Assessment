<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_ibmrt_gdpva.GuardiumProcessorVulnerabilityTest</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>IBM Guardium processor script for adding third party vulnerability entries</description>
        <name>GuardiumProcessorVulnerabilityTest</name>
        <script><![CDATA[var GuardiumProcessorVulnerabilityTest = Class.create();

GuardiumProcessorVulnerabilityTest.VUL_ENTRY_FIELDS = {
    id: false,
    category: false, // Category Name, Test Type
    product: false, // Database Type
    vendor: false, // User defined ref 1, User defined ref 2
    solution: false, // User defined notes
    name: false,
    normalized_severity: false,
    source_severity: false,
    stig_severity: false,
    summary: false,
    source: false,
    source_instance: false,
    last_modified: false,
    cve_id: false,
    cves_list: false,

    access_complexity: true,
    access_vector: true,
    active_exploit: true,
    active_nd_container_vis: true,
    active_nd_vis: true,
    authentication: true,
    availability_impact: true,
    collateral_damage_potential: true,
    confidentiality_impact: true,
    count_active_container_vi: true,
    count_active_vi: true,
    cwe_id: true,
    date_published: true,
    easily_exploitable: true,
    exploit: true,
    exploit_attack_vector: true,
    exploit_skill_level: true,
    exploitability: true,
    integrity_impact: true,
    malware_kit: true,
    max_risk_score: true,
    percent_container_vi_complete: true,
    percent_nd_container_vi_complete: true,
    percent_nd_vi_complete: true,
    percent_vi_complete: true,
    preferred_solution: false,
    public_exploit: true,
    recalculate_flag: true,
    references: true,
    remediation_level: true,
    remediation_type: true,
    report_confidence: true,
    risk_rating: true,
    risk_score: true,
    score: true,
    score_generated: true,
    security_requirements_ar: true,
    security_requirements_cr: true,
    security_requirements_ir: true,
    source_pci: true,
    source_pci_severity: true,
    source_risk_rating: true,
    source_risk_score: true,
    target_distribution: true,
    temporal_score: true,
    threat: true,
    total_container_vis: true,
    total_nd_container_vis: true,
    total_nd_vis: true,
    total_vis: true,
    v2_exploitability_subscore: true,
    v2_impact_subscore: true,
    v2_vector_string: true,
    v3_attack_complexity: true,
    v3_attack_vector: true,
    v3_availability_impact: true,
    v3_base_score: true,
    v3_confidentiality_impact: true,
    v3_exploit_code_maturity: true,
    v3_exploitability_subscore: true,
    v3_impact_subscore: true,
    v3_integrity_impact: true,
    v3_privileges_required: true,
    v3_remediation_level: true,
    v3_report_confidence: true,
    v3_scope_change: true,
    v3_temporal_score: true,
    v3_user_interaction: true,
    v3_vector_string: true
};

GuardiumProcessorVulnerabilityTest.CVE_REG_EX = /[CEVW]+[- ][0-9]+[- ][0-9]*/g;

GuardiumProcessorVulnerabilityTest.prototype =
    Object.extendsObject(GuardiumProcessorBase, {

        beforeProcessReport: function(reportData) {
            this.sn_vul_tpv = new sn_vul.ThirdPartyVulnerability(
                GuardiumAPI.TITLE,
                this.integrationGr.sys_id,
                this.integrationRunGr.sys_id
            );

            try {
                this.sn_vulc_ct = new sn_vulc.ComplianceTest(GuardiumAPI.TITLE);
            } catch (er) {}

            this.failed_types = ',' + (this.preferences.getValue('test_failure_type') || '') + ',';
            this.user_def_sev = gs.getProperty('x_ibmrt_gdpva.user_defined.severity', '1');

            var ccCheckbox = this.preferences.getValue('ignore_config_compliance') || '';
            this.allowConfigCompliance = this.sn_vulc_ct &&
                ('1' == ccCheckbox || 'true' == ccCheckbox || true == ccCheckbox); // reverse logic
        },

        beforeCM: function(cm, data) {
            if (!this.gAPI) {
                this.gAPI = new GuardiumAPI(GuardiumAPI.getGlideRecordCM(cm.sys_id, true));
                //this.gAPI.authenticate();
            }
        },

        processEntry: function(datum, cm) {
            datum = this.createOrUpdateDefinition(datum);

            //- Add or update Compliance Test -//
            var ct_rec = this.transformCT(datum);
            if (ct_rec) {
                // create compliance test
                var ct_entry = this.sn_vulc_ct.createOrUpdateTest(ct_rec);
                if (ct_entry.inserted) {
                    this.inserted_cc++;
                } else
                if (ct_entry.updated) {
                    this.updated_cc++;
                } else {
                    this.skipped_cc++;
                }
                return ct_entry.sys_id;
            }

            //- Add or update Third Party Vulnerability Test -//
            var vt_rec = this.transformVT(datum);
            if (vt_rec) {

                // let script library find duplicate
                var vt_entry = this.sn_vul_tpv.createOrUpdateVulnerability(vt_rec);

                // if nothing created or updated, then create manually
                var sn_rec = new GlideRecord('sn_vul_third_party_entry');
                if (!vt_entry.sys_id) {
                    sn_rec.initialize();
                } else {
                    if (!sn_rec.get(vt_entry.sys_id)) {
                        this.skipped_vi++;
                        return vt_entry.sys_id;
                    }
                }

                // Ensure fields are set!!
                var doUpdate = false;
                for (var p in GuardiumProcessorVulnerabilityTest.VUL_ENTRY_FIELDS) {
                    if (vt_rec[p] && vt_rec[p] != sn_rec.getValue(p)) {
                        sn_rec.setValue(p, vt_rec[p]);
                        doUpdate = true;
                    }
                }

                // Insert or Update
                if (vt_entry.insert || !vt_entry.sys_id) {
                    vt_entry.sys_id = vt_entry.sys_id ? sn_rec.update() : sn_rec.insert();
                    this.inserted_vi++;
                } else
                if (doUpdate) {
                    vt_entry.sys_id = sn_rec.update();
                    this.updated_vi++;
                } else {
                    this.skipped_vi++;
                    return vt_entry.sys_id;
                }

                // Make sure ref data is called
                try {
                    this.sn_vul_tpv._handleReferenceData(
                        vt_entry.sys_id, vt_entry.id, vt_rec.referenceData
                    );
                } catch (e) {}

                return vt_entry.sys_id;
            }
            return '';
        },

        generateTestID: function() {
            var gr = new GlideRecord('x_ibmrt_gdpva_test_definition');
            gr.orderByDesc('servicenow_id');
            gr.orderByDesc('timestamp'); // this assumes that the test created recently has the highest test_id value
            gr.setLimit(1);
            gr.query();
            if (gr.next()) {
                try {
                    var num = gr.getValue('test_id') - 0;
                    if (num > 19999) {
                        num++;
                    } else {
                        num += 20000;
                    }
                    return '' + num; // stringify					
                } catch (e) {}
            }
            return '20000'; // dummy value in case there are no entries
        },

        createOrUpdateDefinition: function(datum, useExisting) {
            try {
                var testName = (datum['Test Description'] || '').substring(0, 1000);
                var testID = (datum['Test ID'] || '');
                var dsType = datum['Datasource Type'] || 'EMPTY';

                var sys_id = '';
                var gr = new GlideRecord('x_ibmrt_gdpva_test_definition');
                if (testID) {
                    gr.addQuery('test_id', '=', testID);
                } else {
                    gr.addQuery('test_description', '=', testName);
                }
                gr.query();
                while (gr.next()) {
                    if (dsType == 'EMPTY' || dsType == gr.getValue('datasource_type')) {
                        sys_id = gr.getUniqueValue();
                        break;
                    }
                    if ('EMPTY' == gr.getValue('datasource_type')) {
                        sys_id = gr.getUniqueValue();
                    }
                }
                if (sys_id) {
                    gr.get(sys_id);
                } else {
                    gr.initialize();
                    useExisting = false;
                }

                var essentialFields = [{
                        fld: 'test_id',
                        key: 'Test ID',
                        def: datum['Test ID'] || this.generateTestID()
                    },
                    {
                        fld: 'test_description',
                        key: 'Test Description',
                        def: ''
                    },
                    {
                        fld: 'test_type',
                        key: 'Test Type',
                        def: ''
                    },
                    {
                        fld: 'datasource_type',
                        key: 'Datasource Type',
                        def: ''
                    },
                    {
                        fld: 'external_reference',
                        key: 'External Reference',
                        def: ''
                    },
                    {
                        fld: 'stig_reference',
                        key: 'STIG Reference',
                        def: ''
                    },
                    {
                        fld: 'stig_severity',
                        key: 'STIG Severity',
                        def: ''
                    },
                    {
                        fld: 'severity',
                        key: 'Severity',
                        def: ''
                    },
                    {
                        fld: 'category_name',
                        key: 'Category Name',
                        def: ''
                    },
                    {
                        fld: 'user_defined_reference_one',
                        key: 'User defined reference one',
                        def: ''
                    },
                    {
                        fld: 'user_defined_reference_two',
                        key: 'User defined reference two',
                        def: ''
                    },
                    {
                        fld: 'user_defined_notes',
                        key: 'User defined notes',
                        def: ''
                    },
                    {
                        fld: 'description',
                        key: 'Short Description',
                        def: ''
                    },
                    {
                        fld: 'timestamp',
                        key: 'Timestamp',
                        def: this.gAPI.adjustTimeFromGuardium(datum['Timestamp']),
                        override: true
                    }
                ];

                // Set all other fields
                var doUpdate = false;
                for (var i = 0; i < essentialFields.length; i++) {
                    var key = essentialFields[i].key;
                    var fld = essentialFields[i].fld;
                    var def = essentialFields[i].def;
                    var val = essentialFields[i].override ? def : datum[key] || def;
                    if (useExisting) {
                        datum[key] = gr.getValue(fld) || val;
                    } else {
                        datum[key] = val;
                        if (datum[key] && datum[key] != gr.getValue(fld)) {
                            gr.setValue(fld, datum[key]);
                            doUpdate = true;
                        }
                    }
                }

                // return a normalized test id
                datum['ServiceNow ID'] = 'Guardium-' + this.normalizeId(datum['Test ID']);
                if (!useExisting || datum['ServiceNow ID'] != gr.getValue('servicenow_id')) {
                    gr.setValue('servicenow_id', datum['ServiceNow ID']);
                }

                if (!sys_id) {
                    sys_id = gr.insert();
                } else {
                    doUpdate && gr.update();
                }
                datum['Test Ref'] = sys_id;
            } catch (e) {
                GuardiumLog.error('Error processing: ' + datum['Test Description'], this.type, e);
            }
            return datum;
        },

        normalizeId: function(id) {
            var s = '00000' + id;
            return s.substring(s.length - 5);
        },

        transformCT: function(datum) {
            // create test def if compliance is installed and this is not CVE
            if (this.allowConfigCompliance && this.failed_types.indexOf(',' + datum['Test Type'] + ',') < 0) {
                var test_date = this.gAPI.adjustTimeFromGuardium(datum['Timestamp']);
                var test_name_brief = datum['ServiceNow ID'] || 'Guardium-' + this.normalizeId(datum['Test ID']);
                var test_name = (
                    datum['Test Description'] ||
                    datum["External Reference"] ||
                    datum["STIG Reference"] ||
                    test_name_brief
                ).substring(0, 512);
                var test_id = test_name_brief.substring(0, 512);

                var rec = this.sn_vulc_ct.newTest(test_id);
                rec.source = GuardiumAPI.TITLE;
                rec.source_id = test_id;
                rec.source_category = this.getLabel(datum['Category Name']);
                rec.source_sub_category = this.getLabel(datum['Test Type']);
                rec.short_description = [datum['Datasource Type'] || 'EMPTY', test_name].join(' - ');
                rec.description = [
                    "* Description:\n" + (datum['Short Description'] || '').trim(),
                    "* Test Reference 1:\n" + (datum['User defined reference one'] || '').trim(),
                    "* Test Reference 2:\n" + (datum['User defined reference two'] || '').trim(),
                    "* Test Notes:\n" + (datum['User defined notes'] || '').trim()
                ].join('\n\n');
                var sev = this.convertSeverity((
                    '1' == this.user_def_sev ? datum['User defined reference one'] :
                    '2' == this.user_def_sev ? datum['User defined reference two'] :
                    '') || datum['Severity']);
                if (99 == sev) {
                    // user defined value is not a priority value
                    rec.source_criticality = this.getLabel(datum['Severity']);
                } else {
                    rec.source_criticality = this.getLabel((
                        '1' == this.user_def_sev ? datum['User defined reference one'] :
                        '2' == this.user_def_sev ? datum['User defined reference two'] :
                        '') || datum['Severity']);
                }
                rec.source_created = test_date;
                rec.source_udpated = this.dt_now;

                return rec;
            }
            return null;
        },

        transformVT: function(datum) {
            // DO NOT create test def if compliance is installed and this is not CVE
            if (this.allowConfigCompliance && this.failed_types.indexOf(',' + datum['Test Type'] + ',') < 0) {
                return null;
            }
            var test_date = this.gAPI.adjustTimeFromGuardium(datum['Timestamp']);
            var test_name_brief = datum['ServiceNow ID'] || 'Guardium-' + this.normalizeId(datum['Test ID']);
            var test_name = (
                datum['Test Description'] ||
                datum["External Reference"] ||
                datum["STIG Reference"] ||
                test_name_brief
            ).substring(0, 512);
            var test_id = test_name_brief.substring(0, 255);

            var rec = this.sn_vul_tpv.newVulnerability(test_id); // limit ID to 255 chars

            // Add external and NVD data
            rec = this.addExternalData(datum, rec);

            // Category, Test Type
            rec.category = [this.getLabel(datum['Category Name']),
                this.getLabel(datum['Test Type'])
            ].join(', ');

            // solution summary
            var arrSolution = [];
            var arrFields = ['User defined reference one', 'User defined reference two', 'User defined notes'];
            for (var f = 0; f < arrFields.length; f++) {
                var val = (datum[arrFields[f]] || '').trim();
                if (val) {
                    arrSolution.push('<h4>' + arrFields[f] + '</h4>' + val.replaceAll('\n', '<br/>'));
                }
            }
            rec.solution = arrSolution.join('<br/><br/>');

            rec.name = test_name;
            var sev = this.convertSeverity((
                '1' == this.user_def_sev ? datum['User defined reference one'] :
                '2' == this.user_def_sev ? datum['User defined reference two'] :
                '') || datum['Severity']);
            rec.normalized_severity = rec.source_severity =
                (99 == sev ? this.convertSeverity(datum['Severity']) : sev);
            rec.stig_severity = this.getLabel(datum['STIG Severity'] || datum['Severity']);

            rec.product = datum['Datasource Type'] || 'EMPTY';
            rec.summary = datum['Short Description'];
            rec.source = GuardiumAPI.TITLE;
            rec.source_instance = this.integrationGr.sys_id;
            rec.date_published = test_date;
            rec.last_modified = test_date;
            rec.access_vector = datum['CVSS Access Vector'] || ''; // v2 vector
            rec.score = (datum['CVSS Score'] || '0') - 0; // v2 score: convert to number

            return rec;
        },

        addExternalData: function(datum, rec) {
            // Find all references to CVE and CWE
            var keys = {};
            var match;
            var asValues = [
                datum["External Reference"] || datum["STIG Reference"] || datum['Test Description'] || '',
                datum['Category Name'] || '',
                datum['Test Type'] || '',
                datum['Short Description'] || ''
            ];
            for (var v = 0; v < asValues.length; v++) {
                var value = asValues[v];
                if (value.indexOf('CVE') == 0 || value.indexOf('CWE') == 0) {
                    match = value.match(GuardiumProcessorVulnerabilityTest.CVE_REG_EX);
                    if (match && match.length > 0) {
                        for (var m = 0; m < match.length; m++) {
                            var k = match[m].replaceAll(' ', '-');
                            if (!keys[k]) keys[k] = true;
                        }
                    }
                }
            }

            if (!rec.cves) rec.cves = [];
            if (!rec.referenceData) rec.referenceData = [];
            if (!rec.cve_array) rec.cve_array = [];

            // Add link to Guardium Test Def
            rec.referenceData.push({
                name: 'GUARDIUM',
                description: 'Test ID: ' + datum['Test ID'],
                url: '/now/nav/ui/classic/params/target/x_ibmrt_gdpva_test_definition.do%3Fsys_id%3D' + datum['Test Ref']
            });

            var bFirst = true;
            for (var key in keys) {
                if (bFirst) {
                    rec = this.copyNVD(key, rec);
                    bFirst = false;
                } else {
                    rec = this.appendNVD(key, rec);
                }
                if (0 == key.indexOf('CVE')) {
                    rec.cves.push({
                        id: key,
                        url: 'https://nvd.nist.gov/vuln/detail/' + key
                    });
                    rec.referenceData.push({
                        name: 'NIST',
                        description: rec.product,
                        url: 'https://nvd.nist.gov/vuln/detail/' + key
                    });
                } else
                if (0 == key.indexOf('CWE')) {
                    var a = key.split('-');
                    if (a.length > 1) {
                        rec.cves.push({
                            id: key,
                            url: 'https://cwe.mitre.org/data/definitions/' + a[1] + '.html'
                        });
                        rec.referenceData.push({
                            name: 'MITRE',
                            description: rec.product,
                            url: 'https://cwe.mitre.org/data/definitions/' + a[1] + '.html'
                        });
                    }
                }
            }

            // list of all CVE references
            rec.cves_list = rec.cve_array.join(',');
            try {
                delete rec.cve_array;
            } catch (e) {}

            return rec;
        },

        copyNVD: function(key, rec) {
            if (key) {
                try {
                    var gr_nvd = new GlideRecord('sn_vul_nvd_entry');
                    gr_nvd.addQuery('id', '=', key);
                    gr_nvd.setLimit(1);
                    gr_nvd.query();
                    if (gr_nvd.next()) {
                        GuardiumLog.debug('NVD copy to Guardium: ' + key, this.type);
                        for (var f in GuardiumProcessorVulnerabilityTest.VUL_ENTRY_FIELDS) {
                            if (GuardiumProcessorVulnerabilityTest.VUL_ENTRY_FIELDS[f] && gr_nvd.getValue(f)) {
                                rec[f] = gr_nvd.getValue(f);
                            }
                        }
                        rec['cve_id'] = gr_nvd.getUniqueValue();
                        rec['cve_array'].push(gr_nvd.getUniqueValue());
                    } else {
                        GuardiumLog.debug('NVD not found: ' + key, this.type);
                    }
                } catch (e) {
                    GuardiumLog.error('', this.type, e);
                }
            }
            return rec;
        },

        appendNVD: function(key, rec) {
            if (key) {
                try {
                    var gr_nvd = new GlideRecord('sn_vul_nvd_entry');
                    gr_nvd.addQuery('id', '=', key);
                    gr_nvd.orderByDesc('sys_updated_on'); // get most recent
                    gr_nvd.setLimit(1);
                    gr_nvd.query();
                    if (gr_nvd.next()) {
                        rec['cve_array'].push(gr_nvd.getUniqueValue());
                    }
                } catch (e) {}
            }
            return rec;
        },

        convertSeverity: function(grd_severity) {
            if (!grd_severity) return '';
            // CRITICAL,MAJOR,MINOR,INFO,CAUTION,CAT I,CAT II,CAT III
            switch (grd_severity.toUpperCase()) {
                case 'CRITICAL':
                    return 1;
                case 'MAJOR':
                case 'CAT I':
                    return 2;
                case 'MINOR':
                case 'CAT II':
                    return 3;
                case 'CAUTION':
                case 'CAT III':
                    return 4;
                case 'INFO':
                    return 5;
            }
            return 99;
        },

        type: 'GuardiumProcessorVulnerabilityTest'
    });]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-01-14 16:22:58</sys_created_on>
        <sys_id>72716ae987094950387c64280cbb35b3</sys_id>
        <sys_mod_count>119</sys_mod_count>
        <sys_name>GuardiumProcessorVulnerabilityTest</sys_name>
        <sys_package display_value="IBM Guardium Data Protection" source="x_ibmrt_gdpva">400d30552fa0111049572f2ef699b65a</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="IBM Guardium Data Protection">400d30552fa0111049572f2ef699b65a</sys_scope>
        <sys_update_name>sys_script_include_72716ae987094950387c64280cbb35b3</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2023-06-15 15:58:34</sys_updated_on>
    </sys_script_include>
</record_update>
