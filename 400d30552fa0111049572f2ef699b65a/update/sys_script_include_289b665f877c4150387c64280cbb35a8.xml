<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_ibmrt_guard.GuardiumProcessorDatasource</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>IBM Guardium data-source processor script</description>
        <name>GuardiumProcessorDatasource</name>
        <script><![CDATA[var GuardiumProcessorDatasource = Class.create();
GuardiumProcessorDatasource.prototype =
    Object.extendsObject(GuardiumProcessorBase, {

        beforeProcessReport: function() {
            this.GuardTransform = new GuardiumTransformMap();
            this._initializeTransformCacheDI();
            this._initializeTransformCacheDC();
            this.prefUseExportMap = '1' == this.preferences.getValue('im_use_export_map');
            this.prefSyncDelete = false && '1' == this.preferences.getValue('sync_del_db');
            this.prefAppendMonitorFlag = '1' == this.preferences.getValue('monitor_flag');
            this.prefCreateCI =
                'configuration_item' == this.preferences.getValue('discovered_database') ||
                'ci_and_di' == this.preferences.getValue('discovered_database');
            this.prefCreateDI =
                'discovered_item' == this.preferences.getValue('discovered_database') ||
                'ci_and_di' == this.preferences.getValue('discovered_database');
        },

        beforeCM: function(cm, data) {
            this.delete_db = {};

            this.gAPI = new GuardiumAPI(GuardiumAPI.getGlideRecordCM(cm.sys_id, true));
            this.gAPI.authenticate();
        },

        processEntry: function(datum, cm, firstSync) {
            var grd_rec = null;

            // -------------------------------------
            // proccess 'Data-Sources' report entry
            // -------------------------------------
            var isDatasourceReport = !datum['Modified Entity'];
            if (isDatasourceReport) {
                // parse database record into a structure with ServiceNow fields
                grd_rec = this.transformDatasourceReport(datum, cm.sys_id);

                // process datasource entry
                return this.processDatasource(cm, grd_rec, datum);
            }

            // -------------------------------------
            // else, process 'DataSource Changes' entry
            // -------------------------------------
            var grd_change = this.transformChangeReport(datum, cm.sys_id);
            if (!grd_change) return null;

            // handle operation
            switch (grd_change.operation) {
                case 'INSERT':
                case 'UPDATE':
                    // fall into code below the switch
                    break;

                case 'DELETE':
                    // process list after all changes are process as the name could have changed
                    this.delete_db[grd_change.name] = true;
                    return null;
                default:
                    // unhandled operation
                    return null;
            }

            // fetch backend record
            try {
                var reportParams = {
                    DataSourceNameLike: grd_change.name,
                    QUERY_FROM_DATE: '1970-01-01 12:00:00'
                };
                var response = this.gAPI.getReportData("Data-Sources", reportParams);
                // GRD-62463: response from Guardium REST-API should have had an error code but does not.
                //  If there is a valid data source, it will be an arrray.
                // var response = this.gAPI.get('datasource', {name: grd_change.name});
                if (!response || !response.data || !response.data.length) return null;

                // parse database record into a structure with ServiceNow fields
                // grd_rec = this.transformDatasourceEntry(response.data[0], cm.sys_id);
                grd_rec = this.transformDatasourceReport(response.data[0], cm.sys_id);

                // process datasource entry
                return this.processDatasource(cm, grd_rec, response.data[0]);

            } catch (e) {
                gs.error(
                    this.type +
                    ' - Error fetching datasource: ' + grd_change.name +
                    " \n " + (e.message || e)
                );
            }
            return null;
        },

        processDatasource: function(cm, grd_rec, datum) {
            var exists = false;

            // find record associated with CM
            var sn_rec = new GlideRecord(GuardiumAPI.TABLE_DB_GDP);
            sn_rec.addQuery(GuardiumAPI.CMDB_COL_CM, '=', grd_rec[GuardiumAPI.CMDB_COL_CM]);
            sn_rec.addQuery(GuardiumAPI.CMDB_COL_DB_ID, '=', grd_rec[GuardiumAPI.CMDB_COL_DB_ID]);
            sn_rec.orderBy('sys_created_on'); // oldest first
            sn_rec.query();
            while (sn_rec.next()) {
                exists = true;
                break;
            }

            if (!exists) {
                sn_rec = new GlideRecord(GuardiumAPI.TABLE_DB_GDP);
                sn_rec.initialize();
            } else {
                // GRD-62328: test results report contains the "name" of the database 
                //  tested not the ID. Therefore, keep multiple records of the same 
                //  database to match with old test results.
                this.handleDuplicateDatasources(sn_rec, grd_rec);
            }

            // Map incoming fields to destination fields
            for (var p in grd_rec) {
                sn_rec.setValue(p, grd_rec[p]);
            }

            // make sure there is a database map record
            var ref = this.getDatabaseTypeRef(grd_rec[GuardiumAPI.CMDB_COL_DB_TYPE]);
            if (!ref) {
                // need to create a new DB MAP record as it does not exist
                var gr_map = new GlideRecord(GuardiumAPI.TABLE_DB_MAP);
                gr_map.initialize();
                gr_map.setValue('database_type', grd_rec[GuardiumAPI.CMDB_COL_DB_TYPE]);
                ref = gr_map.insert();
                if (this.log_level <= 0) {
                    gs.info("Inserted new transform map: " + grd_rec[GuardiumAPI.CMDB_COL_DB_TYPE]);
                }
                // make a new cache map for the updated entry
                this._initializeTransformCacheDI();
            }

            // Find and link CMDB_CI record
            var di_sys_id = sn_rec.getValue('discovered_item');
            var ci_sys_id = sn_rec.getValue('database_instance');

            if (!ci_sys_id) {
                // parse database record into a structure with ServiceNow fields
                var table = grd_rec['database_instance_class'];

                // find a similar record
                ci_sys_id = this.findMatchingDatabase(grd_rec, table);
                if (!ci_sys_id) {
                    if (this.prefCreateCI) {
                        ci_sys_id = this.insertDatabaseInstanceOrCatalog(table, grd_rec, datum);
                    }

                    if (this.prefCreateDI) {
                        // if this is a newly matched database, add it to the "Discovered" table
                        di_sys_id = this.insertDiscoveredItem(ci_sys_id, grd_rec);
                    }
                }
            }

            // create reference to existing CMDB_CI record
            sn_rec.setValue('database_instance', ci_sys_id);
            sn_rec.setValue('discovered_item', di_sys_id);

            // Insert or Update
            if (!exists) {
                sn_rec.insert();
                this.inserted++;
            } else {
                sn_rec.update();
                this.updated++;
            }

            // return a unique key for the database
            return [cm.sys_id, grd_rec[GuardiumAPI.CMDB_COL_DB_ID]].join(':');
        },

        afterCM: function(cm, entry_map) {
            var sn_rec;

            // trim databases on database change event
            for (var db_name in this.delete_db) {
                sn_rec = new GlideRecord(GuardiumAPI.TABLE_DB_GDP);
                sn_rec.addQuery(GuardiumAPI.CMDB_COL_CM, '=', cm.sys_id);
                sn_rec.addQuery('name', '=', db_name);
                sn_rec.query();
                if (sn_rec.next()) {
                    sn_rec.setWorkflow(false);
                    sn_rec.deleteRecord();
                    this.deleted++;
                }
            }

            // trim databases if this is the first time sync
            if (cm.is_first_sync) {

                // find all ServiceNow datasource records associated with this CM
                sn_rec = new GlideRecord(GuardiumAPI.TABLE_DB_GDP);
                sn_rec.addQuery(GuardiumAPI.CMDB_COL_CM, '=', cm.sys_id);
                sn_rec.query();
                while (sn_rec.next()) {
                    // build the same ID used in entry_map
                    var entry_id = [cm.sys_id, sn_rec.getValue(GuardiumAPI.CMDB_COL_DB_ID)].join(':');
                    // is this entry part of the report results?
                    if (!entry_map[entry_id]) {
                        // remove deleted datasource
                        sn_rec.setWorkflow(false);
                        sn_rec.deleteRecord();
                        this.deleted++;
                    }
                }
            }
        },

        getDatabaseTypeRef: function(dbType) {
            return (this._lookupByType[dbType] ?
                this._lookupByType[dbType].sys_id :
                '');
        },

        getInstanceClass: function(dbType) {
            return (this._lookupByType[dbType] ?
                this._lookupByType[dbType].db_instance_class :
                '') || GuardiumAPI.TABLE_DB;
        },

        getDatabaseFieldMap: function(dbType) {
            var map = {};

            // special properties for the db type and class
            var fieldMap = this._lookupByType[dbType] || {};
            for (var p in fieldMap) {
                var v = fieldMap[p];
                // the database_name, database_type, and service_name have map (object) values 
                if (v && ("object" == typeof(v))) {
                    map[v.sn_name] = v.grd_name;
                }
            }

            return map;
        },

        getDatabaseQueryMap: function(dbType) {
            // return a list of defined database attributes that can be used to find a matching database
            var map = {
                'fqdn': true,
                'tcp_port': true,
            };

            // if the database_name or service_name corresponding field in ServiceNow is defined, use it
            var fieldMap = this._lookupByType[dbType] || {};
            if (fieldMap) {
                for (var fld in {
                        database_name: true,
                        service_name: true
                    }) {
                    try {
                        var v = fieldMap[fld].sn_name;
                        if (v) map[v] = true;
                    } catch (e) {
                        gs.warn("No DB Instance transform for type: " + dbType);
                    }
                }
            }
            return map;
        },

        getCatalogFieldMap: function(dbType) {
            var map = {};

            // special properties for the db type and class
            var fieldMap = this._catalogByType[dbType] || this._catalogByType['*'];
            for (var p in fieldMap) {
                var v = fieldMap[p];
                // the database_name, database_type, and service_name have map (object) values 
                if (v && ("object" == typeof(v))) {
                    map[v.sn_name] = v.grd_name;
                }
            }

            return map;
        },

        getCatalogQueryMap: function(dbType) {
            // return a list of defined database attributes that can be used to find a matching database
            var map = {};

            // if the database_name or service_name corresponding field in ServiceNow is defined, use it
            var fieldMap = this._catalogByType[dbType] || this._catalogByType['*'];
            if (fieldMap) {
                for (var fld in {
                        database_name: true,
                        service_name: true
                    }) {
                    try {
                        var v = fieldMap[fld].sn_name;
                        if (v) map[v] = true;
                    } catch (e) {
                        gs.warn("No DB Catalog transform for type: " + dbType);
                    }
                }
            }
            return map;
        },

        findMatchingDatabase: function(grd_rec, table) {
            var db_type = grd_rec[GuardiumAPI.CMDB_COL_DB_TYPE];

            // find the entry with a matching table type
            var gr_di = new GlideRecord(table);

            // query from standard attributes and get additional query attributes
            var queryMap = this.getDatabaseQueryMap(db_type);

            // we just need the ServiceNow field names (the properties of the map)
            var asQuery = ["table=" + table];
            for (var p in queryMap) {
                // if the database record has a value for the property, add it to the lookup
                // for example, the database FQDN and Port will be added to the lookup if there is a value
                if (grd_rec[p]) {
                    asQuery.push(p + '=' + grd_rec[p]);
                    gr_di.addQuery(p, '=', grd_rec[p]);
                }
            }
            if (this.log_level <= 0) {
                gs.info("Find matching DB Instance:\n " + asQuery.join(", "));
            }

            // return first found record
            gr_di.query();
            if (gr_di.next()) {
                return gr_di.getUniqueValue();
            }

            return this.findMatchingCatalog(grd_rec, table);
        },

        findMatchingCatalog: function(grd_rec, table) {
            var db_type = grd_rec[GuardiumAPI.CMDB_COL_DB_TYPE];

            // try database instance with linked database catalog
            var gr_di = new GlideRecord(table);
            gr_di.addQuery('fqdn', '=', grd_rec['fqdn']);
            gr_di.addQuery('tcp_port', '=', grd_rec['tcp_port']);
            gr_di.query();
            if (gr_di.next()) {
                var table_dc = (this._catalogByType[db_type] || this._catalogByType['*']).class_name;
                var catalogMap = this.getCatalogQueryMap(db_type);
                var gr_dc = new GlideRecord(table_dc);
                // catalog must be linked to DI
                gr_dc.addQuery('database_instance', '=', gr_di.getUniqueValue());
                // add other params
                var asQuery = ["table=" + table_dc];
                for (var p in catalogMap) {
                    // if the database record has a value for the property, add it to the lookup
                    // for example, the database FQDN and Port will be added to the lookup if there is a value
                    if (grd_rec[p]) {
                        asQuery.push(p + '=' + grd_rec[p]);
                        gr_dc.addQuery(p, '=', grd_rec[p]);
                    }
                }
                if (this.log_level <= 0) {
                    gs.info("Find matching DB Catalog:\n " + asQuery.join(", "));
                }
                gr_dc.query();
                if (gr_dc.next()) {
                    return gr_dc.getUniqueValue();
                }
            }
            return null;
        },

        insertDatabaseInstanceOrCatalog: function(table, grd_rec, datum) {
            try {
                var sys_id = '';
                var gr_di = new GlideRecord(table);
                gr_di.addQuery('fqdn', '=', grd_rec['fqdn']);
                gr_di.addQuery('tcp_port', '=', grd_rec['tcp_port']);
                gr_di.query();
                if (gr_di.next()) {

                    // Database Instance exists, create a Database Catalog
                    var db_type = grd_rec[GuardiumAPI.CMDB_COL_DB_TYPE];
                    var fieldMap = this._catalogByType[db_type] || this._catalogByType['*'];
                    var gr_dc = new GlideRecord(fieldMap.class_name);
                    gr_dc.initialize();
                    gr_dc.setValue('database_instance', gr_di.getUniqueValue());
                    for (var p in {
                            database_name: true,
                            service_name: true
                        }) {
                        if (fieldMap[p].sn_name) {
                            gr_dc.setValue(fieldMap[p].sn_name, datum[fieldMap[p].grd_name]);
                        }
                    }
                    sys_id = gr_dc.insert();

                } else {
                    // Create Database Instance
                    gr_di.initialize();

                    // Map incoming fields to destination fields
                    for (var f in grd_rec) {
                        var fieldName = this._getFieldName(f);
                        gr_di.setValue(fieldName, grd_rec[f]);
                    }
                    if (this.prefAppendMonitorFlag) {
                        gr_di.setValue('monitor', true);
                    }
                    sys_id = gr_di.insert();
                }

                return sys_id;
            } catch (e) {
                gs.error(this.type + " - Error insertDatabaseInstanceOrCatalog: " + JSON.stringify(e));
            }
            return null;
        },

        insertDiscoveredItem: function(db_sys_id, grd_rec) {
            try {
                grd_rec['class'] = grd_rec['database_instance_class'];

                // Create a new record in the "Discovered Items" table
                // * similar to sn_vul.ImportHost._createSrc( ... )
                //
                var sn_dis = new GlideRecord("sn_sec_cmn_src_ci");
                sn_dis.initialize();

                sn_dis.setValue('source', this.integrationGr.sys_id);
                sn_dis.setValue('source_id', GuardiumAPI.TITLE);
                sn_dis.setValue('cmdb_ci', db_sys_id + ""); // make sure this is not null
                sn_dis.setValue('integration_run', this.integrationRunGr.sys_id);

                // Give the user some hint on the database info
                sn_dis.setValue('initial_source_data', JSON.stringify(grd_rec));
                sn_dis.setValue('source_data', JSON.stringify(grd_rec));

                sn_dis.setValue('last_auth_scan_date',
                    new GlideDateTime(this.integrationRunGr.getValue('sys_created_on')));

                return sn_dis.insert();
            } catch (e) {
                gs.error(this.type + " - Error insertDiscoveredItem: " + JSON.stringify(e));
            }
            return null;
        },

        handleDuplicateDatasources: function(sn_orig, grd_rec) {
            // GRD-62328: test results report contains the "name" of the database 
            //  tested not the ID. Therefore, keep multiple records of the same 
            //  database with different "name" values to match with old test results.
            //
            // We want the original doc to get the new DB name due to 
            //  asset_id reference in "Test Result Details" engine. If
            //  the asset_id changes, then the Vulnerability Detection Item
            //  unique key changes.  And that causes an issue matching it with VIT.
            //
            var dt_now = new GlideDateTime();
            if (grd_rec['name'] != sn_orig.getValue('name')) {
                var sys_id_orig = sn_orig.getUniqueValue();
                var found = false;

                // Find all records with same ID and make sure old names are marked "Deprecated"
                var sn_rec = new GlideRecord(GuardiumAPI.TABLE_DB_GDP);
                sn_rec.addQuery(GuardiumAPI.CMDB_COL_CM, '=', grd_rec[GuardiumAPI.CMDB_COL_CM]);
                sn_rec.addQuery(GuardiumAPI.CMDB_COL_DB_ID, '=', grd_rec[GuardiumAPI.CMDB_COL_DB_ID]);
                sn_rec.orderBy('sys_created_on'); // oldest first
                sn_rec.query();
                while (sn_rec.next()) {
                    if (sys_id_orig == sn_rec.getUniqueValue()) {
                        continue;
                    }
                    if ('Deprecated' != sn_rec.getValue('status')) {
                        sn_rec.setValue('status', 'Deprecated');
                        sn_rec.setValue('status_date', dt_now);
                        sn_rec.setValue('status_detail',
                            'Data source was renamed in IBM Guardium.' +
                            ' After test result details are imported and linked to appropriate' +
                            ' CMDB configuration items, it is safe to remove this data source.'
                        );
                        sn_rec.setWorkflow(false);
                        sn_rec.update();
                    }
                    if (grd_rec['name'] == sn_rec.getValue('name')) {
                        found = true;
                    }
                }
                if (!found) {
                    // Create a new entry with "Deprecated" status
                    sn_orig.setValue('status', 'Deprecated');
                    sn_orig.setValue('status_date', dt_now);
                    sn_orig.setValue('status_detail',
                        'Data source was renamed in IBM Guardium.' +
                        ' After test result details are imported and linked to appropriate' +
                        ' CMDB configuration items, it is safe to remove this data source.'
                    );
                    sn_orig.setWorkflow(false);
                    sn_orig.insert();

                    // make sure we don't change the sn_orig GR passed in
                    sn_orig.get(sys_id_orig);
                }
            }
        },

        _getFieldName: function(fldGRD) {
            switch (fldGRD) {
                case 'custom_fields':
                    return 'running_process_key_parameters';
                case 'custom_url':
                    return 'running_process_command';
                case 'datasource_description':
                    return 'description';
            }
            return fldGRD;
        },

        _initializeTransformCacheDI: function() {
            this._lookupByType = {};

            var map = this.GuardTransform.getMapDI();
            for (var db_type in map) {
                var entry = map[db_type];

                this._lookupByType[db_type] = {
                    sys_id: entry['sys_id'],
                    db_instance_class: entry['database_instance_class'],

                    database_name: {
                        grd_name: "Database Name",
                        sn_name: entry['database_name'] || ''
                    },
                    database_type: {
                        grd_name: "Datasource Type",
                        sn_name: db_type
                    },
                    service_name: {
                        grd_name: "Service Name",
                        sn_name: entry['service_name'] || ''
                    }
                };
            }
        },

        _initializeTransformCacheDC: function() {
            this._catalogByType = {};

            var map = this.GuardTransform.getMapDC();
            for (var db_type in map) {
                var entry = map[db_type];

                this._catalogByType[db_type] = {
                    sys_id: entry['sys_id'],
                    class_name: entry['class_name'],

                    database_name: {
                        grd_name: "Database Name",
                        sn_name: entry['database_name'] || ''
                    },
                    database_type: {
                        grd_name: "Datasource Type",
                        sn_name: db_type
                    },
                    service_name: {
                        grd_name: "Service Name",
                        sn_name: entry['service_name'] || ''
                    }
                };
            }
        },

        transformChangeReport: function(datum, cm_sys_id) {
            /*
            			"Timestamp": "2022-03-14 11:15:55",
            			"User Name": "servicenow",
            			"Activity Type": "3",
            			"Modified Entity": "DATASOURCE",
            			"Object Description": "Fake Oracle 90001 Updated",
            			"Host Name": "abc04",
            			"Activity Type ID": "3",
            			"Activity Type Description": "DELETE",
            			"Count of Guardium User Activity Audits": "1"
            */
            if ('DATASOURCE' != datum['Modified Entity']) return null;
            var rec = {
                name: datum['Object Description'],
                operation: datum['Activity Type Description'],
                timestamp: datum['Timestamp'],
            };
            return rec;
        },

        transformDatasourceEntry: function(datum, cm_sys_id) {
            // strip the id from the URL
            var arr = datum['DatasourceId'].split('=');
            var ds_id = arr[arr.length - 1];

            var rec = {
                // common Database Instance properties
                name: datum['Name'],
                fqdn: datum['Host'],
                tcp_port: "0" == datum['Port'] ? "" : datum['Port'],
                attributes: datum['ConProperty'],
                discovery_source: GuardiumAPI.TITLE,

                datasource_id: ds_id,
                datasource_type: datum['DatasourceType'],
                datasource_description: datum['Description'],
                custom_fields: datum['CustomFields'],
                custom_url: datum['CustomUrl'],

                database_name: datum['DbName'],
                service_name: datum['ServiceName'],

                status: "1" == datum['Status'] ? 'Connection successful' : datum['Status'],
                status_date: this.gAPI.adjustTimeFromGuardium(datum['LastChecked']),
                status_detail: datum['LastCheckedMessage'],

                fqdn_cm: cm_sys_id
            };

            // custom Guardium properties
            datum['Database Name'] = datum['DbName']; // utility field
            datum['Service Name'] = datum['ServiceName']; // utility field

            // special properties for the db type
            var map = this.getDatabaseFieldMap(rec[GuardiumAPI.CMDB_COL_DB_TYPE]);
            for (var p in map) {
                rec[p] = datum[map[p]];
            }

            return rec;
        },

        transformDatasourceReport: function(datum, cm_sys_id) {
            /*
            			"Datasource Id": "20001",
            			"Datasource Type": "POSTGRESQL",
            			"Datasource Name": "DPS: PostgreSQL 11 on rh73mssql01",
            			"Datasource Description": "",
            			"Host": "xxxx0001.abc.com",
            			"Port": "5555",
            			"Service Name": "",
            			"Database Name": "postgres",
            			"User Name": "dbuser",
            			"Shared": "true",
            			"Connection Properties": "",
            			"Severity": "NONE",
            			"Status": "Connection successful",
            			"Last Checked": "2021-09-21 20:13:44",
            			"Last Checked Message": "Connection successful from host 'abc03'.",
            			"Last Connect": "2021-09-21 20:50:43",
            			"Owner": "guarduser",
            			"Custom": "{}"
            */
            var rec = {
                // common Database Instance properties
                name: datum['Datasource Name'],
                fqdn: datum['Host'],
                tcp_port: "0" == datum['Port'] ? "" : datum['Port'],
                attributes: datum['Connection Properties'],
                discovery_source: GuardiumAPI.TITLE,

                datasource_id: datum['Datasource Id'],
                datasource_type: datum['Datasource Type'],
                datasource_description: datum['Datasource Description'],
                custom_fields: datum['Custom'],
                custom_url: datum['Custom URL'] || '',

                database_name: datum['Database Name'],
                service_name: datum['Service Name'],

                status: datum['Status'],
                status_date: this.gAPI.adjustTimeFromGuardium(datum['Last Checked']),
                status_detail: datum['Last Checked Message'],

                fqdn_cm: cm_sys_id
            };

            var table = this.getInstanceClass(rec[GuardiumAPI.CMDB_COL_DB_TYPE]);
            rec['database_instance_class'] = table;

            // special properties for the db type
            var map = this.getDatabaseFieldMap(rec[GuardiumAPI.CMDB_COL_DB_TYPE]);
            for (var p in map) {
                rec[p] = datum[map[p]];
            }

            return rec;
        },

        type: 'GuardiumProcessorDatasource'
    });]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-01-07 17:22:51</sys_created_on>
        <sys_id>289b665f877c4150387c64280cbb35a8</sys_id>
        <sys_mod_count>121</sys_mod_count>
        <sys_name>GuardiumProcessorDatasource</sys_name>
        <sys_package display_value="IBM Guardium Vulnerability Assessment" source="x_ibmrt_guard">400d30552fa0111049572f2ef699b65a</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="IBM Guardium Vulnerability Assessment">400d30552fa0111049572f2ef699b65a</sys_scope>
        <sys_update_name>sys_script_include_289b665f877c4150387c64280cbb35a8</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2022-07-13 12:12:17</sys_updated_on>
    </sys_script_include>
</record_update>
