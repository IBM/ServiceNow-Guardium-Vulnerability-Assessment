<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_ibmrt_gdpva.GuardiumProcessorDatasource</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>IBM Guardium data-source processor script</description>
        <name>GuardiumProcessorDatasource</name>
        <script><![CDATA[var GuardiumProcessorDatasource = Class.create();
GuardiumProcessorDatasource.prototype =
    Object.extendsObject(GuardiumProcessorBase, {

        runReconcile: false,

        beforeProcessReport: function() {
            this.GuardTransform = new GuardiumTransformMap();
            this._initializeTransformCacheDI();
            this._initializeTransformCacheDC();
            var prop = gs.getProperty('x_ibmrt_gdpva.ci_lookup_enabled', true);
            this.doCILookup = 'true' == prop || '1' == prop || true == prop;
            this.updateVersion();
            try {
                this.snVulImportHost = new sn_vul.ImportHost();
            } catch (e) {}
        },

        afterProcessReport_deprecated: function(reportData) {
            // run reconciliation after all data sources are imported
            if (reportData.hasMoreData) {
                return;
            }
            try {
                GuardiumLog.debug(
                    'Queue unmatched items reconciliation',
                    this.type
                );
                // run reconciliation engine asynchronously
                gs.eventQueue(
                    'x_ibmrt_gdpva.ReconcileUnmatched',
                    null,
                    this.integrationGr.getValue('instance'),
                    'Reconcile unmatched Guardium data sources',
                    ""
                );
            } catch (e) {
                GuardiumLog.error('Queue Reconcile Engine', this.type, e);
            }
        },

        beforeCM: function(cm, data) {
            this.ds_deleted = {};
            this.ds_changed = {};
            this.ds_not_found = {};

            this.dtNow = 'Synchronization on ' + (new GlideDateTime()).getValue();

            if (!this.gAPI) {
                this.gAPI = new GuardiumAPI(GuardiumAPI.getGlideRecordCM(cm.sys_id, true));
                this.gAPI.authenticate();
            }

            // Run the reconcile engine on full sync
            this.runReconcile |= cm.is_first_sync;
        },

        afterCM: function(cm, entry_map) {
            var sn_rec;

            // trim databases on database change event
            for (var db_name in this.ds_deleted) {
                sn_rec = new GlideRecord(GuardiumAPI.TABLE_DB_GDP);
                sn_rec.addQuery(GuardiumAPI.CMDB_COL_CM, '=', cm.sys_id);
                sn_rec.addQuery('name', '=', db_name);
                sn_rec.query();
                while (sn_rec.next()) {
                    sn_rec.setWorkflow(false);
                    sn_rec.setValue('status', GuardiumAPI.STATUS.DEPRECATED);
                    sn_rec.deleteRecord();
                    this.deleted++;
                    GuardiumLog.debug(
                        'Data Source deleted: ' + db_name,
                        this.type + '.afterCM'
                    );
                }
            }
        },

        processEntry: function(datum, cm, firstSync) {
            var grd_rec = null;

            // -------------------------------------
            // proccess 'Data-Sources' report entry
            // -------------------------------------
            var isChangeReport = (datum['Modified Entity'] && datum['Object Description']);
            if (!isChangeReport) {
                // parse database record into a structure with ServiceNow fields
                grd_rec = this.transformDatasourceReport(datum, cm.sys_id);

                // process datasource entry
                return this.processDatasource(grd_rec, !!grd_rec.datasource_id);
            }

            // -------------------------------------
            // else, process 'DataSource Changes' entry
            // -------------------------------------
            var grd_change = this.transformChangeReport(datum, cm.sys_id);
            if (!grd_change) return null;

            // handle operation
            switch (grd_change.operation) {
                case 'LOOKUP':
                    break;

                case 'INSERT':
                case 'UPDATE':
                    return null;

                case 'DEPRECATED':
                    var ds = {
                        name: grd_change.name,
                        fqdn_cm: cm.sys_id,
                        fqdn: '',
                        source_id: '',
                        datasource_id: grd_change.datasource_id,
                        datasource_type: grd_change.datasource_type
                    };

                    // find by ds_id
                    var sn_ds = this.findDatasource(ds, 'id');
                    if (sn_ds && grd_change.name != sn_ds.getValue('name')) {
                        this.handleRenamedDatasources(sn_rec, grd_rec);
                        return sn_ds.getValue('source_id');
                    }

                    // find by name
                    if (!sn_ds) sn_ds = this.findDatasource(ds, 'name');
                    if (sn_ds) return sn_ds.getValue('source_id');

                    // else, fall into code below the switch
                    break;

                case 'DELETE':
                    // process list after all changes are process as the name could have changed
                    this.ds_deleted[grd_change.name] = true;
                    return null;

                default:
                    // unhandled operation
                    return null;
            }

            // fetch backend record
            if (!this.ds_not_found[grd_change.name] && '-1' != grd_change.datasource_id) {
                try {
                    var params = grd_change.datasource_id ? {
                        id: grd_change.datasource_id
                    } : {
                        name: grd_change.name
                    };
                    var response = this.gAPI.get("datasource", params);
                    // GRD-62463: response from Guardium REST-API should have had an error code but does not.
                    //  If there is a valid data source, it will be an arrray.
                    // var response = this.gAPI.get('datasource', {name: grd_change.name});
                    if (!response || !response.data || !response.data.length) {
                        throw new Error(response.body);
                    } else {

                        // parse database record into a structure with ServiceNow fields
                        grd_rec = this.transformDatasourceEntry(response.data[0], cm.sys_id);

                        // process datasource entry
                        return this.processDatasource(grd_rec, true);
                    }
                } catch (e) {
                    if (!this.ds_not_found[grd_change.name]) {
                        this.ds_not_found[grd_change.name] = true;
                        GuardiumLog.warn('Error fetching datasource: ' + grd_change.name, this.type, e);
                    }
                }
            }

            // create a dummy datasource
            grd_rec = this.transformDatasourceReport({
                "Datasource Description": "Placeholder for test results since data source could not be imported",
                "Status": GuardiumAPI.STATUS.DEPRECATED,
                "Datasource Id": grd_change.datasource_id || '-1',
                "Datasource Name": grd_change.name,
                "Datasource Type": grd_change.datasource_type || 'UNKNOWN'
            }, cm.sys_id);
            return this.processDatasource(grd_rec);

        },

        findDatasource: function(grd_rec, method, isFullRecord) {
            var sId = '';
            var sn_ds = new GlideRecord(GuardiumAPI.TABLE_DB_GDP);
            switch (method) {
                case 'unid':
                    if (!grd_rec['source_id']) return null;
                    sn_ds.addQuery('source_id', '=', grd_rec['source_id']);
                    break;
                case 'id':
                    if (!grd_rec['datasource_id'] || '-1' == grd_rec['datasource_id']) return null;
                    sn_ds.addQuery('datasource_id', '=', grd_rec['datasource_id']);
                    sn_ds.addQuery('fqdn_cm', '=', grd_rec['fqdn_cm']);
                    break;
                case 'name':
                default:
                    if (!grd_rec['name']) return null;
                    sn_ds.addQuery('name', '=', grd_rec['name']);
                    sn_ds.addQuery('fqdn_cm', '=', grd_rec['fqdn_cm']);
                    break;
            }
            sn_ds.query();
            while (sn_ds.next()) {
                sId = sn_ds.getUniqueValue();
                if (GuardiumAPI.STATUS.DEPRECATED != sn_ds.getValue('status')) {
                    return sn_ds;
                }
            }
            if (sId) {
                if (sn_ds.get(sId)) {
                    return sn_ds;
                }
            }
            if (!isFullRecord) {
                GuardiumLog.debug(
                    "Data source not found by " + method, this.type, grd_rec);
            }
            return null;
        },

        processDatasource: function(grd_rec, isFullRecord) {
            if (!grd_rec['datasource_type'] || 'N_A' == grd_rec['datasource_type']) {
                GuardiumLog.debug(
                    'Invalid Data Source Type - Skip Synchronization',
                    this.type,
                    this.scrubDatasource(grd_rec)
                );
                this.skipped++;
                return;
            }

            // find record associated with CM
            var exists = true;
            var sn_rec = this.findDatasource(grd_rec, 'id', isFullRecord);
            if (!sn_rec && !isFullRecord) sn_rec = this.findDatasource(grd_rec, 'name', isFullRecord);
            if (!sn_rec) {
                sn_rec = new GlideRecord(GuardiumAPI.TABLE_DB_GDP);
                sn_rec.setWorkflow(false);
                sn_rec.newRecord(); // we want a sys_id to pass to Discovered Item
                exists = false;
            }

            // make sure there is a database map record
            var ref = this.getDatabaseTypeRef(grd_rec);

            // Find and link CMDB_CI record
            var oCILookup = {
                di_sys_id: sn_rec.getValue('discovered_item') || '',
                ci_sys_id: sn_rec.getValue('database_instance') || ''
            };

            if (GuardiumAPI.STATUS.DEPRECATED != grd_rec['status']) {
                // If not there, add it to the "Discovered Item" table.
                oCILookup = this.createOrUpdateDiscoveredItem(oCILookup, grd_rec);
            }

            // create reference to existing CMDB_CI record
            grd_rec['database_instance'] = oCILookup.ci_sys_id || '';
            grd_rec['discovered_item'] = oCILookup.di_sys_id || '';

            if (exists) {
                // GRD-62328: test results report contains the "name" of the database 
                //  tested not the ID. Therefore, keep multiple records of the same 
                //  database to match with old test results.
                this.handleRenamedDatasources(sn_rec, grd_rec) || '';
            }

            // Map incoming fields to destination fields
            var sAction = '';
            var doUpdate = this.copyAllFields(sn_rec, grd_rec);
            if (doUpdate) {
                // Insert or Update
                sn_rec.setWorkflow(false);
                sn_rec.setValue('action', 'synchronized');
                var dt = sn_rec.getValue('sys_updated_on');
                sn_rec.update(this.dtNow);
                if (!exists) {
                    this.inserted++;
                    sAction = 'INSERT';
                } else {
                    if (dt == sn_rec.getValue('sys_updated_on')) {
                        this.skipped++;
                        sAction = 'NO CHANGE';
                    } else {
                        this.updated++;
                        sAction = 'UPDATE';
                    }
                }
            } else {
                this.skipped++;
                sAction = 'NO CHANGE';
            }
            GuardiumLog.debug(
                'Data Source ' + sAction,
                this.type, {
                    datasource_id: grd_rec['datasource_id'],
                    name: grd_rec['name']
                }
            );

            // return a unique key for the database
            return grd_rec.source_id;
        },

        getDatabaseTypeRef: function(grd_rec) {
            var dbType = grd_rec['datasource_type'];
            if (!dbType) return null;
            var ref = this.getDatabaseFieldMap(dbType).sys_id || '';
            if (!ref) {
                // need to create a new DB MAP record as it does not exist
                var gr_map = new GlideRecord(GuardiumAPI.TABLE_DB_MAP);
                gr_map.initialize();
                gr_map.setValue('database_type', grd_rec['datasource_type']);
                ref = gr_map.insert();
                GuardiumLog.debug(
                    "Inserted new transform map: " + grd_rec['datasource_type'], this.type
                );
                // make a new cache map for the updated entry
                this._initializeTransformCacheDI();
            }
            return ref;
        },

        getInstanceClass: function(dbType) {
            return (this.getDatabaseFieldMap(dbType).target_class || 'cmdb_ci_db_instance');
        },

        getDatabaseFieldMap: function(dbType) {
            // special properties for the db type and class
            return this._lookupByType[dbType.toLowerCase()] || {};
        },

        getCatalogQueryMap: function(dbType) {
            // return a list of defined database attributes that can be used to find a matching database
            var map = {};

            // if the database_name or service_name corresponding field in ServiceNow is defined, use it
            var fieldMap = this._catalogByType[dbType.toLowerCase()] || this._catalogByType['*'];
            if (fieldMap) {
                for (var fld in {
                        database_name: true,
                        service_name: true
                    }) {
                    try {
                        var v = fieldMap[fld].sn_name;
                        if (v) map[v] = true;
                    } catch (e) {
                        GuardiumLog.debug("No DB Catalog transform for type: " + dbType, this.type);
                    }
                }
            }
            return map;
        },

        createOrUpdateDiscoveredItem_deprecated: function(oCILookup, payload) {
            // 
            // Do not use this.snVulImportHost.hostImport(...) 
            //  this library will ultimately create a cmdb_ci_unclassed_hardware entry
            //  which does not define a data source or application, but rather a generic hardware device
            //
            var response = oCILookup || {
                ci_sys_id: '',
                di_sys_id: ''
            };
            if (response.di_sys_id) return response;

            try {
                // Add attributes needed by IRE engine
                payload['serial_number_type'] = 'IBM Guardium Data Source';
                payload['mac_address'] = this.macFromSourceID(payload['source_id']);
                payload['ip_address'] = GuardiumAPI.ipv4or6.test(payload['fqdn']) ? payload['fqdn'] : '127.0.0.1';

                GuardiumLog.debug(
                    "Calling sn_vul.ImportHost.hostImport(...) to find or create Discovered Item for: " + payload.name);
                var matchResults = this.snVulImportHost.hostImport(
                    this.integrationGr.getValue('instance'), // Integration Implementation
                    payload, 'source_id',
                    this.integrationRunGr.getUniqueValue()
                );
                if (matchResults) {
                    if (matchResults.disc_item_id) {
                        response.di_sys_id = matchResults.disc_item_id;
                        // if there is empty data produced by sn_cmdb.IdentificationEngine.createOrUpdateCIEnhanced()
                        // add sn_sec_cmn_src_cmdb_map entry to match payload with sn_sec_cmn_src_ci field
                    }
                    if (matchResults.sys_id) {
                        response.ci_sys_id = matchResults.sys_id;
                        // if there is empty data produced by sn_cmdb.IdentificationEngine.createOrUpdateCIEnhanced()
                        // add sn_sec_cmn_src_cmdb_map entry to match payload with sn_sec_cmn_unmatched_ci field
                    }
                    if (matchResults.insert) GuardiumLog.debug("Inserted Discovered Item for: " + payload.name);
                    if (matchResults.update) GuardiumLog.debug("Updated Discovered Item for: " + payload.name);
                }
            } catch (e) {
                GuardiumLog.error('createOrUpdateDiscoveredItem', this.type, e);
            }
            return response;
        },

        createOrUpdateDiscoveredItem: function(oCILookup, payload) {
            // 
            // Code that simulates this.snVulImportHost.hostImport(...)
            //  1. find or create Discovered Item
            //  2. find, match, or create Configuration Item
            //
            var ci_sys_id = oCILookup.ci_sys_id;
            var di_sys_id = oCILookup.di_sys_id;
            var rule_sys_id = oCILookup.rule_sys_id || '';

            try {
                // Create a new record in the "Discovered Items" table
                // * similar to sn_vul.ImportHost._createSrc( ... )
                //
                var sn_dis = new GlideRecord("sn_sec_cmn_src_ci");
                if (di_sys_id) {
                    sn_dis.addQuery('sys_id', '=', di_sys_id);
                } else {
                    sn_dis.addQuery('source_id', '=', payload.source_id);
                    sn_dis.orderByDesc('sys_created_on'); // newest first
                }
                sn_dis.setLimit(1);
                sn_dis.query();
                if (sn_dis.next()) {
                    di_sys_id = sn_dis.getUniqueValue();
                    // ensure there is a cmdb ref
                    if (!sn_dis.getValue('cmdb_ci')) {
                        if (!ci_sys_id) {
                            var oMatch = this.createOrUpdateUnmatchedCI(payload);
                            if (oMatch && oMatch.ci_sys_id) {
                                ci_sys_id = oMatch.ci_sys_id;
                                rule_sys_id = oMatch.rule_sys_id;
                            }
                            // if matching CI Lookup rule, then say so
                            sn_dis.setValue('matching_type', rule_sys_id ? 'matched_by_cilookup' : 'created_by_vr');
                        } else {
                            // already existing CI probably from export
                            this.updateMatchedCI(ci_sys_id, payload);
                            sn_dis.setValue('matching_type', 'matched_by_ire');
                        }
                        payload['ci_sys_id'] = ci_sys_id;
                        sn_dis.setValue('source_data', JSON.stringify(payload));
                        sn_dis.setValue('cmdb_ci', ci_sys_id);
                        sn_dis.setValue('ci_lookup_rule', rule_sys_id);
                        sn_dis.setValue('state', this.getDiscoveredItemState(ci_sys_id));
                        sn_dis.setValue('source_id', payload.source_id);
                        sn_dis.update();
                        GuardiumLog.debug('Updated Discovered Item for: ' + payload.name, this.type);
                    } else {
                        ci_sys_id = sn_dis.getValue('cmdb_ci');
                    }
                } else {
                    sn_dis.initialize();

                    sn_dis.setValue('resource_name', payload.name);
                    sn_dis.setValue('resource_id', payload.datasource_id);

                    sn_dis.setValue('source', this.integrationGr.getValue('instance')); // Integration Instance
                    sn_dis.setValue('source_id', payload.source_id);
                    sn_dis.setValue('integration_run', this.integrationRunGr.getUniqueValue());

                    if (!ci_sys_id) {
                        var oMatch = this.createOrUpdateUnmatchedCI(payload);
                        if (oMatch && oMatch.ci_sys_id) {
                            ci_sys_id = oMatch.ci_sys_id;
                            rule_sys_id = oMatch.rule_sys_id;
                        }
                        // if matching CI Lookup rule, then say so
                        sn_dis.setValue('matching_type', rule_sys_id ? 'matched_by_cilookup' : 'created_by_vr');
                    } else {
                        // already existing CI probably from export
                        this.updateMatchedCI(ci_sys_id, payload);
                        sn_dis.setValue('matching_type', 'matched_by_ire');
                    }
                    sn_dis.setValue('cmdb_ci', ci_sys_id);
                    sn_dis.setValue('ci_lookup_rule', rule_sys_id);
                    sn_dis.setValue('state', this.getDiscoveredItemState(ci_sys_id));
                    payload['ci_sys_id'] = ci_sys_id;
                    sn_dis.setValue('source_data', JSON.stringify(payload));

                    sn_dis.setValue('last_scan_date', payload['status_date']);
                    sn_dis.setValue('last_auth_scan_date', payload['status_data']);

                    di_sys_id = sn_dis.insert();
                    GuardiumLog.debug('Created Discovered Item for: ' + payload.name, this.type);
                }
            } catch (e) {
                GuardiumLog.error('createOrUpdateDiscoveredItem', this.type, e);
            }
            return {
                di_sys_id: di_sys_id,
                ci_sys_id: ci_sys_id,
                rule_sys_id: rule_sys_id
            };
        },

        getDiscoveredItemState: function(ci_sys_id) {
            var gr_ci = new GlideRecord('cmdb_ci');
            if (gr_ci.get(ci_sys_id)) {
                return 'sn_sec_cmn_unmatched_ci' == gr_ci.getRecordClassName() ? 'unmatched' : 'matched';
            }
            return 'unmatched';
        },

        updateMatchedCI: function(ci_sys_id, payload) {
            var gr_ci = new GlideRecord('cmdb_ci');
            if (gr_ci.get(ci_sys_id) && payload['serial_number'] && payload['serial_number'] != gr_ci.getValue('serial_number')) {
                gr_ci.setValue('serial_number', payload['serial_number']);
                gr_ci.setValue('serial_number_type', payload['serial_number_type']);
                gr_ci.update();
            }
        },

        createOrUpdateUnmatchedCI: function(payload) {
            var oResponse = {
                ci_sys_id: '',
                rule_sys_id: ''
            };
            try {
                // Add attributes needed by IRE engine
                payload['serial_number'] = payload.source_id;
                payload['serial_number_type'] = 'IBM Guardium Data Source';
                payload['mac_address'] = this.macFromSourceID(payload['source_id']);
                payload['ip_address'] = GuardiumAPI.ipv4or6.test(payload['fqdn']) ? payload['fqdn'] : '127.0.0.1';
                payload['category'] = 'Resource';
                payload['subcategory'] = 'Database';

                // Find existing record and return it
                var gr_ci = new GlideRecord("cmdb_ci");
                gr_ci.addQuery('serial_number', '=', payload.source_id);
                gr_ci.orderByDesc('sys_created_on'); // newest first
                gr_ci.setLimit(1);
                gr_ci.query();
                if (gr_ci.next()) {
                    oResponse.ci_sys_id = gr_ci.getUniqueValue();
                    return oResponse;
                }

                // Search for a match using CI Lookup Rules
                var oMatch = this.lookupByRuleCI(payload);
                if (oMatch && oMatch.ci_sys_id) {
                    return oMatch;
                }

                // Else, create a new record in the "Unmatched CI" table
                gr_ci = new GlideRecord("sn_sec_cmn_unmatched_ci");
                gr_ci.initialize();
                gr_ci.setValue('source_data', JSON.stringify(payload));

                var fieldMap = {
                    serial_number: payload['serial_number'],
                    serial_number_type: payload['serial_number_type'],
                    ip_address: payload['ip_address'],
                    fqdn: payload['fqdn'],
                    name: payload['name'],
                    short_description: payload['datasource_description'],
                    mac_address: payload['mac_address'],
                    category: payload['category'],
                    subcategory: payload['subcategory'],
                    last_discovered: new GlideDateTime(this.integrationRunGr.getValue('sys_created_on')),
                    discovery_source: 'VR-IBM-Guardium'
                };

                for (var f in fieldMap) {
                    gr_ci.setValue(f, fieldMap[f]);
                }

                oResponse.ci_sys_id = gr_ci.insert();
                GuardiumLog.debug('Created Unmatched CI for: ' + payload.name, this.type);

            } catch (e) {
                GuardiumLog.error('', this.type, e);
            }
            return oResponse;
        },

        lookupByRuleCI: function(ds) {
            if (!this.doCILookup) return {};

            // Runs sn_sec_cmn_ci_lookup_rule
            var gr_rule = new GlideRecord('sn_sec_cmn_ci_lookup_rule');
            gr_rule.addActiveQuery();
            gr_rule.addQuery('source', '=', '24f0f5c687744d10387c64280cbb350c'); // IBM Guardium rules
            gr_rule.orderBy('order');
            gr_rule.query();
            while (gr_rule.next()) {
                try {
                    GuardiumLog.debug('Evaluate CI Lookup Rule: ' + gr_rule.getDisplayValue(), this.type);
                    var fieldName = (gr_rule.getValue('source_field') || 'name').toLowerCase();
                    var ciFieldName = gr_rule.getValue('target_field') || 'correlation_id';
                    var method = gr_rule.getValue('method') || 'script';
                    var ci_sys_id;

                    if ('field_matching' == method) {
                        if (fieldName.startsWith('source_data.')) {
                            var asDotNotation = fieldName.split('.');
                            fieldName = asDotNotation[1];
                        }
                        var gr_ci = new GlideRecord(gr_rule.getValue('target_table') || 'cmdb_ci');
                        gr_ci.addQuery(ciFieldName, '=', ds[fieldName]);
                        gr_ci.addQuery('sys_class_name', '!=', 'sn_sec_cmn_unmatched_ci');
                        gr_ci.addQuery('sys_class_name', '!=', 'cmdb_ci_unclassed_hardware');
                        gr_ci.query();

                        GuardiumLog.debug(
                            'Number of records: ' + gr_ci.getRowCount() +
							'\n where cmdb_ci.' + ciFieldName + ' == "' + ds[fieldName] + '"',
                            this.type
                        );

                        if (gr_ci.next()) {
                            ci_sys_id = gr_ci.getUniqueValue();
                        }
                    } else
                    if ('script' == method) {
                        var evaluator = new GlideScopedEvaluator();
                        evaluator.putVariable('rule', gr_rule);
                        evaluator.putVariable('sourceValue', ds[fieldName]);
                        evaluator.putVariable('sourcePayload', ds);
                        evaluator.putVariable('returnObj', {});
                        ci_sys_id = evaluator.evaluateScript(gr_rule, "script", {});
                    }

                    if (ci_sys_id) {
                        GuardiumLog.debug('Found match from CI Lookup Rule: ' + gr_rule.getDisplayValue(), this.type);
                        return {
                            rule_sys_id: gr_rule.getUniqueValue(),
                            ci_sys_id: ci_sys_id
                        };
                    }
                } catch (e) {
                    GuardiumLog.error('Error CI Lookup Rule', this.type, e);
                }
            }
            return {};
        },

        handleRenamedDatasources: function(sn_orig, grd_rec) {
            // GRD-62328: test results report contains the "name" of the database 
            //  tested not the ID. Therefore, keep multiple records of the same 
            //  database with different "name" values to match with old test results.
            //
            // We want the original doc to get the new DB name due to 
            //  asset_id reference in "Test Result Details" engine.
            // Otherwise, if the asset_id changes, then the Vulnerability Detection Item
            //  unique key changes.  And that causes an issue matching it with VIT.
            //
            if (grd_rec['name'] != sn_orig.getValue('name')) {
                var sys_id_orig = sn_orig.getUniqueValue();
                var found = false;

                // Find all records with same ID and make sure old names are marked "Deprecated"
                var sn_rec = new GlideRecord(GuardiumAPI.TABLE_DB_GDP);
                sn_rec.addQuery('datasource_id', '=', grd_rec['datasource_id']);
                sn_rec.addQuery('fqdn_cm', '=', grd_rec['fqdn_cm']);
                sn_rec.addQuery('status', '!=', GuardiumAPI.STATUS.DEPRECATED);
                sn_rec.addQuery('name' != grd_rec['name']);
                sn_rec.orderBy('sys_created_on'); // oldest first
                sn_rec.query();
                while (sn_rec.next()) {
                    found = true;
                    GuardiumLog.info('Data Source Renamed\nOriginal: "' +
                        sn_rec.getValue('name') +
                        '"\nNew: "' + grd_rec['name'] + '"',
                        this.type
                    );
                    sn_rec.setValue('status_detail',
                        'A renamed IBM Guardium data source was detected.\n\n' +
                        'After test result details are imported and linked to appropriate' +
                        ' CMDB configuration items, it is safe to remove this data source.'
                    );


                    // Set fields
                    sn_rec.setValue('status', GuardiumAPI.STATUS.DEPRECATED);
                    sn_rec.setValue('status_date', this.dt_now);
                    sn_rec.setValue('action', 'synchronized');

                    // Save
                    sn_rec.setWorkflow(false);
                    if (sys_id_orig == sn_rec.getUniqueValue()) {
                        sn_rec.insert();
                        // restore original
                        sn_orig.get(sys_id_orig);
                    } else {
                        sn_rec.update(GuardiumAPI.STATUS.DEPRECATED);
                    }
                }
                return found ? sys_id_orig : '';
            }
        },

        copyAllFields: function(gr, json) {
            var doUpdate = false;
            for (var p in GuardiumAPI.DS_FIELD_MAP) {
                var v = json[p] || '';
                if (GuardiumAPI.DS_FIELD_MAP[p] && v && 'function' == typeof(v.substring)) {
                    v = v.substring(0, GuardiumAPI.DS_FIELD_MAP[p]); // honor max length
                }
                if (v != gr.getValue(p)) {
                    doUpdate = true;
                    gr.setValue(p, v);
                }
            }
            return doUpdate;
        },

        _getFieldName: function(fldGRD) {
            switch (fldGRD) {
                case 'attributes':
                    return 'running_process_key_parameters';
                case 'custom_fields':
                    return 'attributes';
                case 'custom_url':
                    return 'running_process_command';
                case 'datasource_description':
                    return 'description';
            }
            return fldGRD;
        },

        _initializeTransformCacheDI: function() {
            this._lookupByType = {};

            var map = this.GuardTransform.getMapDI();
            for (var db_type in map) {
                var db_type_lower = db_type.toLowerCase();
                var entry = map[db_type_lower];

                this._lookupByType[db_type_lower] = {
                    sys_id: entry['sys_id'],
                    target_class: entry['database_instance_class'],
                    target_database_name: entry['database_name'] || '',
                    target_service_name: entry['service_name'] || ''
                };
            }
        },

        _initializeTransformCacheDC: function() {
            this._catalogByType = {};

            var map = this.GuardTransform.getMapDC();
            for (var db_type in map) {
                var db_type_lower = db_type.toLowerCase();
                var entry = map[db_type_lower];

                this._catalogByType[db_type_lower] = {
                    sys_id: entry['sys_id'],
                    target_class: entry['class_name'],
                    target_database_name: entry['database_name'] || '',
                    target_service_name: entry['service_name'] || ''
                };
            }
        },

        transformChangeReport: function(datum, cm_sys_id) {
            /*
            			"Timestamp": "2022-03-14 11:15:55",
            			"User Name": "servicenow",
            			"Activity Type": "3",
            			"Modified Entity": "DATASOURCE",
            			"Object Description": "Fake Oracle 90001 Updated",
            			"Host Name": "abc04",
            			"Activity Type ID": "3",
            			"Activity Type Description": "DELETE",
            			"Count of Guardium User Activity Audits": "1"
            */
            if ('DATASOURCE' != datum['Modified Entity']) return null;
            var rec = {
                name: datum['Object Description'],
                datasource_id: datum['Object ID'] || datum['Object Id'] ||
                    datum['Datasource ID'] || datum['Datasource Id'] ||
                    datum['Key Value'] || '',
                datasource_type: datum['Datasource Type'] || '',
                operation: (datum['Activity Type Description'] || '').toUpperCase(),
                timestamp: datum['Timestamp'],
            };
            return rec;
        },

        transformDatasourceEntry: function(datum, cm_sys_id) {
            // strip the id from the URL
            var arr = datum['DatasourceId'].split('=');
            var ds_id = arr[arr.length - 1];

            var rec = {
                // common Database Instance properties
                name: datum['Name'],
                fqdn: datum['Host'],
                tcp_port: "0" == datum['Port'] ? "" : datum['Port'],
                attributes: datum['ConProperty'],
                discovery_source: 'VR-IBM-Guardium',

                datasource_id: ds_id,
                datasource_type: datum['DatasourceType'],
                datasource_description: datum['Description'],
                custom_fields: datum['CustomFields'] || '{}',
                custom_url: datum['CustomUrl'],
                severity: this.convertSeverity(datum['Severity']),

                database_name: datum['DbName'],
                service_name: datum['ServiceName'],

                action: 'synchronized',
                status: "0" == datum['Status'] ? 'Connection failed' : 'Connection successful', // core/setup/mysql/QUERY_SQL_ins.sql
                status_date: this.gAPI.adjustTimeFromGuardium(datum['LastChecked']),
                status_detail: datum['LastCheckedMessage'],

                user_name: datum['UserName'] || '',

                fqdn_cm: cm_sys_id
            };

            var table = this.getInstanceClass(rec[GuardiumAPI.CMDB_COL_DB_TYPE]);
            rec['database_instance_class'] = table;

            // special properties for the db type
            var map = this.getDatabaseFieldMap(rec[GuardiumAPI.CMDB_COL_DB_TYPE]);
            for (var p in map) {
                rec[p] = map[p];
            }

            // add all other properties in a single "extra_fields" field
            var oJson = {};
            for (var ef in GuardiumAPI.DS_EXTRA_FIELDS_GET) {
                oJson[GuardiumAPI.DS_EXTRA_FIELDS_GET[ef]] = datum[ef] || '';
            }
            rec['extra_fields'] = JSON.stringify(oJson);

            // parse custom_fields into a list of name=value pairs
            try {
                var fields = rec.custom_fields;
                var list = [];
                for (var f in fields) {
                    list.push(f + '=' + fields[f]);
                }
                rec['custom_fields'] = list.join(',');
            } catch (e) {
                GuardiumLog.error(
                    'Error parsing data source custom fields: ' + rec.custom_fields +
                    '\nConsider installing a patch to address issue: GRD-66033',
                    this.type, e
                );
            }

            // source_id for Discovered Item
            rec['serial_number'] = rec['source_id'] = this.getUniqueID(rec);

            return rec;
        },

        transformDatasourceReport: function(datum, cm_sys_id) {
            /*
         			"Datasource Id": "20001",
           			"Datasource Type": "POSTGRESQL",
           			"Datasource Name": "DPS: PostgreSQL 11 on rh73mssql01",
           			"Datasource Description": "",
           			"Host": "xxxx0001.abc.com",
           			"Port": "5555",
           			"Service Name": "",
           			"Database Name": "postgres",
           			"User Name": "dbuser",
           			"Shared": "true",
           			"Connection Properties": "",
           			"Severity": "NONE",
           			"Status": "Connection successful",
           			"Last Checked": "2021-09-21 20:13:44",
           			"Last Checked Message": "Connection successful from host 'abc03'.",
           			"Last Connect": "2021-09-21 20:50:43",
           			"Owner": "guarduser",
           			"Custom": "{}"
            */
            var rec = {
                // common Database Instance properties
                name: datum['Datasource Name'] || '',
                fqdn: datum['Host'] || '',
                tcp_port: "0" == datum['Port'] ? "" : datum['Port'] || '',
                attributes: datum['Connection Properties'] || '',
                discovery_source: 'VR-IBM-Guardium',

                datasource_id: datum['Datasource Id'] || '',
                datasource_type: datum['Datasource Type'] || '',
                datasource_description: datum['Datasource Description'] || '',
                custom_fields: datum['Custom'] || '{}',
                custom_url: datum['Custom URL'] || '',
                severity: datum['Severity'] || 'NONE',

                database_name: datum['Database Name'] || '',
                service_name: datum['Service Name'] || '',

                action: 'synchronized',
                status: datum['Status'] || '',
                status_date: this.gAPI.adjustTimeFromGuardium(datum['Last Checked']),
                status_detail: datum['Last Checked Message'] || '',

                user_name: datum['User Name'] || '',

                fqdn_cm: cm_sys_id
            };

            var table = this.getInstanceClass(rec.datasource_type);
            rec['database_instance_class'] = table;

            // special properties for the db type
            var map = this.getDatabaseFieldMap(rec.datasource_type);
            for (var p in map) {
                rec[p] = map[p];
            }

            // parse custom_fields into a list of name=value pairs
            if (rec.custom_fields && rec.custom_fields.length <= 2) {
                rec.custom_fields = '';
            } else {
                try {
                    GuardiumLog.debug("About to parse Custom Fields");
                    // work-around for GRD-62463: strip out extra escape chars
                    var fields = JSON.parse(rec.custom_fields.replaceAll('\\', ''));
                    var list = [];
                    for (var f in fields) {
                        list.push(f + '=' + fields[f]);
                    }
                    rec.custom_fields = list.join(',');
                } catch (e) {
                    GuardiumLog.warn(
                        'Error parsing data source custom fields: ' + rec.custom_fields +
                        '\nConsider installing a patch to address issue: GRD-66033',
                        this.type, e
                    );
                }
            }

            // source_id for Discovered Item
            rec['serial_number'] = rec['source_id'] = this.getUniqueID(rec);

            return rec;
        },

        scrubDatasource: function(ds_orig) {
            // hide sensitive fields
            var ds = {};
            var sensitive = GuardiumAPI.DS_SENSITIVE_FIELDS.join(',');
            for (var p in ds_orig) {
                if (sensitive.includes(p)) {
                    // not sure if String.padStart() exists in ES5 ... use alternate solution
                    ds[p] = '****************************************'.substring(0, ds_orig[p].length);
                } else {
                    ds[p] = ds_orig[p];
                }
            }
            return ds;
        },

        updateVersion: function() {
            try {
                var dsExpected = '1.3.6';
                var dsActual = gs.getProperty('x_ibmrt_gdpva.version.datasource', '1.3.3');
                if (dsExpected != dsActual) {
                    GuardiumLog.info("Upgrading source_id for all data sources", this.type);
                    // minimize the chance that multiple threads update at the same time
                    gs.setProperty('x_ibmrt_gdpva.version.datasource', dsExpected);

                    var ds_count = 0;
                    var di_count = 0;

                    // convert source_id 
                    var sn_ds = new GlideRecord(GuardiumAPI.TABLE_DB_GDP);
                    sn_ds.query();
                    while (sn_ds.next()) {
                        // generate new source_id
                        var rec = {
                            fqdn_cm: sn_ds.getValue('fqdn_cm') || '',
                            name: sn_ds.getValue('name') || ''
                        };
                        for (var f in this.UNIQUE_ID_FIELDS) {
                            rec[f] = sn_ds.getValue(f) || '';
                        }
                        var source_id = this.getUniqueID(rec);
                        if (source_id == sn_ds.getValue('source_id')) continue;

                        // update DS
                        sn_ds.setValue('source_id', source_id);
                        sn_ds.update();
                        ds_count++;

                        // update DI
                        if (sn_ds.getValue('discovered_item')) {
                            var sn_di = new GlideRecord('sn_sec_cmn_src_ci');
                            if (sn_di.get(sn_ds.getValue('discovered_item'))) {
                                try {
                                    var jsonDI = JSON.parse(sn_di.getValue('source_data') || '{}');
                                    jsonDI['source_id'] = source_id;
                                    jsonDI['serial_number'] = source_id;
                                    sn_di.setValue('source_data', JSON.stringify(jsonDI));
                                } catch (e) {}
                                sn_di.setValue('source_id', source_id);
                                sn_di.update();
                                di_count++;
                            }
                        }
                    }

                    GuardiumLog.info([
                        "Number of upgraded data sources: " + ds_count,
                        "Number of upgraded discovered items: " + di_count
                    ].join('\n'));
                }
            } catch (e) {
                GuardiumLog.error('Upgrade Data Source', this.type, e);
            }
        },

        convertSeverity: function(severityVal) {
            var severityNum = severityVal - 0;
            if (isNaN(severityNum)) return severityVal;
            if (severityNum > 8) return "HIGH";
            if (severityNum > 4) return "MED";
            if (severityNum > 0) return "LOW";
            return "NONE";
        },

        UNIQUE_ID_FIELDS: {
            fqdn: true,
            tcp_port: true,
            datasource_type: true,
            service_name: true,
            database_name: true
        },

        getUniqueID: function(rec) {
            var arr = [];
            for (var f in this.UNIQUE_ID_FIELDS) {
                if (rec[f]) arr.push(rec[f]);
            }
            var unid = arr.join(':');
            if (-1 == unid.indexOf(':')) {
                // no data
                unid = [rec.fqdn_cm, rec.name].join(':');
            }
            return '' + this.generateHashCode(unid);
        },

        macFromSourceID: function(id) {
            // Format for mac: 15-56-7D-54-93-0D
            var sID = ('' + id).replaceAll('-', '0') + 'FFFFFFFFFFFF'; // Fill remaining characters
            var aID = [];
            for (var i = 0; aID.length < 6; i += 2) {
                aID.push(sID.substr(i, 2));
            }
            return aID.join('-');
        },

        type: 'GuardiumProcessorDatasource'
    });]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-01-07 17:22:51</sys_created_on>
        <sys_id>289b665f877c4150387c64280cbb35a8</sys_id>
        <sys_mod_count>103</sys_mod_count>
        <sys_name>GuardiumProcessorDatasource</sys_name>
        <sys_package display_value="IBM Guardium Data Protection" source="x_ibmrt_gdpva">400d30552fa0111049572f2ef699b65a</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="IBM Guardium Data Protection">400d30552fa0111049572f2ef699b65a</sys_scope>
        <sys_update_name>sys_script_include_289b665f877c4150387c64280cbb35a8</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2023-09-21 12:03:51</sys_updated_on>
    </sys_script_include>
</record_update>
