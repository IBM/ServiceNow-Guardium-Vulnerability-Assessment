<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_fix">
    <sys_script_fix action="INSERT_OR_UPDATE">
        <before>false</before>
        <description>Repair Vulnerable Item and Detection first_found (SGA-25). &#13;
Close orphan Vulnerable Item when test severity has changed (SGA-22).</description>
        <name>IBM Guardium Vulnerability Data</name>
        <record_for_rollback>true</record_for_rollback>
        <script><![CDATA[function fixFirstFoundDetection() {
    /**
     * first_found is empty when the result is "PASS" or "ERROR"
     * 
     * This code sets first_found to the last_found date to make it non-empty.
     */
    var sTableDET = 'sn_vul_detection';
    try {
        if (!gs.tableExists(sTableDET)) {
            gs.warn('Cannot complete. Table [' + sTableDET + '] does not exist.');
            return;
        }

        var total = 0;
        var gr = new GlideRecord(sTableDET);
        gr.addQuery('source', '=', 'IBM Guardium');
        gr.addNullQuery('first_found');
        gr.query();
        while (gr.next()) {
            gr.setValue('first_found', gr.getValue('last_found'));
            gr.update();
            if (gr.getValue('first_found')) {
                total++;
            }
        }

        gs.info("Number of Detections where first_found is updated: " + total);
    } catch (e) {
        gs.error('Error updating [' + sTableDET + ']: ' + e.message + '\n' + e.stack);
    }
}

function fixFirstFoundVulnerableItem() {
    /**
     * first_found is empty when the result is "PASS" or "ERROR"
     * 
     * If the detection changes from "ERROR" to "FAIL" and there is now a first_found value, ServiceNow code fails to update the Vulnerable Item.
     * This code sets first_found to the last_found date to make it non-empty.
     */
    var sTableDET = 'sn_vul_detection';
    var sTableLink = 'vulnerable_item';
    var sTableVIT = 'sn_vul_vulnerable_item';
    try {
        if (!gs.tableExists(sTableDET)) {
            gs.warn('Cannot complete. Table [' + sTableDET + '] does not exist.');
            return;
        }
        if (!gs.tableExists(sTableVIT)) {
            gs.warn('Cannot complete. Table [' + sTableVIT + '] does not exist.');
            return;
        }

        var total = 0;
        var gr = new GlideRecord(sTableDET);
        gr.addQuery('source', '=', 'IBM Guardium');
        gr.addNullQuery('vulnerable_item.first_found');
        gr.query();
        while (gr.next()) {
            // update linked item
            var vit = new GlideRecord(sTableVIT);
            if (gr.getValue(sTableLink) && vit.get(gr.getValue(sTableLink))) {
                total++;
                vit.setValue('first_found', gr.getValue('first_found'));
                vit.update();
            }
        }

        gs.info("Number of Vulnerable Items where first_found is updated: " + total);
    } catch (e) {
        gs.error('Error updating [' + sTableVIT + ']: ' + e.message + '\n' + e.stack);
    }
}

function fixOrphanVulnerableItem() {
    /**
     * If the test severity is changed in the Guardium assessment, a new test definition is created in ServiceNow since risk calculators use the severity in calculation of the Vulnerable Item risk score.
     * Because the test result references a new test definition, a new Vulnerable Item is created, thus causing what might be considered "duplicate" Vulnerable Items.
     * This code will close older Vulnerable Items where the severity has been updated.
     */
    var sTableDET = 'sn_vul_detection';
    var sTableVIT = 'sn_vul_vulnerable_item';
    var sTableTestDef = 'sn_vul_third_party_entry';
    var sTableGuardium = 'x_ibmrt_gdpva_test_definition';
    var sTableCCResult = 'sn_vulc_result';
    try {
        if (!gs.tableExists(sTableDET)) {
            gs.warn('Cannot complete. Table [' + sTableDET + '] does not exist.');
            return;
        }
        if (!gs.tableExists(sTableVIT)) {
            gs.warn('Cannot complete. Table [' + sTableVIT + '] does not exist.');
            return;
        }
        if (!gs.tableExists(sTableTestDef)) {
            gs.warn('Cannot complete. Table [' + sTableTestDef + '] does not exist.');
            return;
        }


        var agg = new GlideAggregate(sTableGuardium);
        agg.groupBy('short_description'); // test ID
        agg.addAggregate('COUNT', 'short_description');
        agg.addAggregate('GROUP_CONCAT_DISTINCT', 'servicenow_id');
        agg.query();
        while (agg.next()) {
            // if count > 1,a test with multiple severities has been found
            if (agg.getAggregate('COUNT', 'short_description') > 1) {
                var testList = agg.getAggregate('GROUP_CONCAT_DISTINCT', 'servicenow_id');
                var testDescription =
                    agg.getValue('short_description') + ' | ' + testList;

                // Split test list into an array
                var arrTestID = (testList || '').split(',');

                // Close related vulnerable items
                var total = closeVulnerableItems(arrTestID);
                gs.info(
                    'Multiple severities found for test: ' +
                    testDescription +
                    ' | Number of VIT test results closed: ' + total
                );

                try {
                    if (gs.tableExists(sTableCCResult)) {
                        // Close related Configuration Compliance results 
                        var totalCC = closeCCResults(arrTestID);
                        gs.info(
                            'Multiple severities found for test: ' +
                            testDescription +
                            ' | Number of CC test results closed: ' + totalCC
                        );
                    }
                } catch (ecc) {}
            }
        }
    } catch (e) {
        gs.error('Error updating [' + sTableVIT + ']: ' + e.message + '\n' + e.stack);
    }
}

function getTestSysID(tableName, fieldName, testID) {
    var gr = new GlideRecord(tableName);
    gr.addQuery(fieldName, '=', testID);
    gr.query();
    if (gr.next()) {
        return gr.getUniqueValue();
    }
    return '';
}

function closeVulnerableItems(arrTestID) {
    var total = 0;
    var sTableVIT = 'sn_vul_vulnerable_item';
    var sTableTestDef = 'sn_vul_third_party_entry';

    // convert servicenow_id to sys_id
    var arrSysID = [];
    for (var i = 0; i < arrTestID.length; i++) {
        var sysID = getTestSysID(sTableTestDef, 'id', arrTestID[i]);
        if (sysID) arrSysID.push('vulnerability=' + sysID);
    }
    if (0 == arrSysID.length) return 0;

    // close open VIT
    var gr = new GlideRecord(sTableVIT);
    gr.addQuery('source', '=', 'IBM Guardium');
    gr.addEncodedQuery(arrSysID.join('^OR'));
    gr.orderByDesc('cmdb_ci');
    gr.orderByDesc('sys_created_on'); // newest first
    gr.query();
    var cmdb_ci = '';
    var vit = '';
    while (gr.next()) {
        if (cmdb_ci != gr.getValue('cmdb_ci')) {
            // save info about the newest test result
            cmdb_ci = gr.getValue('cmdb_ci');
            vit = gr.getValue('number');
        } else {
            total++;
            // if the ticket is open, close it
            if ('1' == gr.getValue('state').toString()) {
                gr.setValue('active', false);
                gr.setValue('state', 3); // closed
                gr.setValue('substate', 5); // cancelled
                gr.setValue(
                    'close_notes',
                    'Duplicate vulnerable item with updated severity: ' + vit
                );
                gr.update();
            }
        }
    }
    return total;
}

function closeCCResults(arrTestID) {
    var total = 0;
    var sTableCCResult = 'sn_vulc_result';
    var sTableTestDef = 'sn_vulc_test';

    // convert to sys_id
    var arrSysID = [];
    for (var i = 0; i < arrTestID.length; i++) {
        var sysID = getTestSysID(sTableTestDef, 'source_id', arrTestID[i]);
        if (sysID) arrSysID.push('control=' + sysID);
    }
    if (0 == arrSysID.length) return 0;

    // close open VIT
    var gr = new GlideRecord(sTableCCResult);
    gr.addQuery('source', '=', 'IBM Guardium');
    gr.addEncodedQuery(arrSysID.join('^OR'));
    gr.orderByDesc('cmdb_ci');
    gr.orderByDesc('sys_created_on'); // newest first
    gr.query();
    var cmdb_ci = '';
    var vit = '';
    while (gr.next()) {
        if (cmdb_ci != gr.getValue('cmdb_ci')) {
            // save info about the newest test result
            cmdb_ci = gr.getValue('cmdb_ci');
            vit = gr.getValue('number');
        } else {
            total++;
            // if the ticket is open, close it
            if ('1' == gr.getValue('state').toString()) {
                gr.setValue('state', 3); // closed
                gr.setValue('resolution', 3); // cancelled
                gr.setValue(
                    'resolution_reason',
                    'Duplicate test result with updated severity: ' + vit
                );
                gr.update();
            }
        }
    }
    return total;
}

fixFirstFoundDetection();
fixFirstFoundVulnerableItem();
fixOrphanVulnerableItem();]]></script>
        <sys_class_name>sys_script_fix</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-04-01 15:37:56</sys_created_on>
        <sys_id>709403e5479d06105f9c1d98036d43a9</sys_id>
        <sys_mod_count>12</sys_mod_count>
        <sys_name>IBM Guardium Vulnerability Data</sys_name>
        <sys_package display_value="IBM Guardium Data Protection" source="x_ibmrt_gdpva">400d30552fa0111049572f2ef699b65a</sys_package>
        <sys_policy/>
        <sys_scope display_value="IBM Guardium Data Protection">400d30552fa0111049572f2ef699b65a</sys_scope>
        <sys_update_name>sys_script_fix_709403e5479d06105f9c1d98036d43a9</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-04-03 14:30:49</sys_updated_on>
        <unloadable>false</unloadable>
    </sys_script_fix>
</record_update>
