<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_ibmrt_gdpva.GuardiumProcessorDatasourceGroup</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>IBM Guardium database groups processor script</description>
        <name>GuardiumProcessorDatasourceGroup</name>
        <script><![CDATA[var GuardiumProcessorDatasourceGroup = Class.create();
GuardiumProcessorDatasourceGroup.APP_TYPES = {
    'Security Assessment': true,
    'ALL': true
};

GuardiumProcessorDatasourceGroup.prototype =
    Object.extendsObject(GuardiumProcessorBase, {

        beforeProcessReport: function() {
            this._initializeLookupCache();
        },

        beforeCM: function(cm, data) {
            this.gAPI = new GuardiumAPI(GuardiumAPI.getGlideRecordCM(cm.sys_id, true));
            this.gAPI.authenticate();
        },

        processEntry: function(datum, cm) {
            var exists = false;
            var grd_rec = this.transform(datum, cm);

            // must pertain to VA
            if (!(grd_rec[GuardiumAPI.GRP_COL_APP_TYPE] in GuardiumProcessorDatasourceGroup.APP_TYPES)) {
                this.skipped++;
                return;
            }

            // ignore the "All datasources" group
            if ('DYNAMIC' == grd_rec[GuardiumAPI.GRP_COL_GRP_TYPE] && !grd_rec[GuardiumAPI.GRP_COL_DB_TYPE]) {
                this.skipped++;
                return;
            }

            // find any previously loaded record ... if name changed in Guardium, we lose this connection
            var sn_rec = new GlideRecord(GuardiumAPI.TABLE_GRP);
            sn_rec.addQuery(GuardiumAPI.GRP_COL_NAME, '=', grd_rec[GuardiumAPI.GRP_COL_NAME]);
            sn_rec.addQuery(GuardiumAPI.GRP_COL_CM, '=', cm.sys_id);
            sn_rec.setLimit(1);
            sn_rec.query();
            if (sn_rec.next()) {
                exists = true;
            }

            if (exists) {
                // is it the same?  if so, skip
                var skip = true;
                for (var prop in grd_rec) {
                    if (grd_rec[prop] != sn_rec.getValue(prop)) {
                        skip = false;
                        break;
                    }
                }
                if (skip) {
                    this.skipped++;
                    return [cm.sys_id, grd_rec[GuardiumAPI.GRP_COL_NAME]].join(':');
                }
            }

            if (!exists) {
                sn_rec.initialize();
            }

            // Map incoming fields to destination fields
            for (var p in grd_rec) {
                sn_rec.setValue(p, grd_rec[p]);
            }

            // Insert or Update
            var grp_sys_id = null;
            sn_rec.setWorkflow(false);
            if (exists) {
                // Force update of original name
                sn_rec.setValue(GuardiumAPI.GRP_COL_NAME_ORIG, grd_rec[GuardiumAPI.GRP_COL_NAME]);

                grp_sys_id = sn_rec.update();
                this.updated++;
            } else {
                // Insert new group
                grp_sys_id = sn_rec.insert();
                this.inserted++;
            }

            // If group type is STATIC, then create Data Source Group Map
            if ('STATIC' == grd_rec[GuardiumAPI.GRP_COL_GRP_TYPE]) {
                try {
                    // Ask IBM Guardium what datasources are part of this group
                    var response = this.gAPI.get('datasource_group', {
                        groupName: grd_rec[GuardiumAPI.GRP_COL_NAME_ORIG]
                    });

                    // Process the group members (Guardium DataSources)
                    if (response && response.data && response.data.length) {

                        // establish a cache to use later when looking for duplicate GlideRecords
                        var memberCache = {};
                        var member;
                        for (var n = 0; n < response.data.length; n++) {
                            member = response.data[n];

                            // find ServiceNow data-source entry that matches the Guardium DataSource
                            var sn_db = new GlideRecord(GuardiumAPI.TABLE_DB_GDP);
                            sn_db.addQuery('fqdn_cm', '=', cm.sys_id);
                            sn_db.addQuery('name', '=', member['name']);
                            sn_db.setLimit(1);
                            sn_db.query();
                            if (sn_db.next()) {
                                member.sys_id = sn_db.getUniqueValue();
                                memberCache[member.sys_id] = member;
                            }
                        }

                        // create or update static group members
                        var sn_map = new GlideRecord(GuardiumAPI.TABLE_GRP_MEMBER);
                        sn_map.addQuery('group', '=', grp_sys_id);
                        sn_map.query();
                        while (sn_map.next()) {
                            member = memberCache[sn_map.getValue('datasource')];
                            if (!member) {
                                // member was removed by IBM Guardium
                                sn_map.setWorkflow(false);
                                sn_map.deleteRecord();
                            } else {
                                member.processed = true;
                            }
                        }

                        // process any unprocessed entries
                        for (var db_sys_id in memberCache) {
                            if (!memberCache[db_sys_id].processed) {
                                // database was added by IBM Guardium
                                sn_map.initialize();
                                sn_map.setValue('group', grp_sys_id);
                                sn_map.setValue('datasource', db_sys_id);
                                sn_map.setWorkflow(false);
                                sn_map.insert();
                                memberCache[db_sys_id].processed = true;
                            }
                        }
                    }
                } catch (errGet) {
                    GuardiumLog.error('', this.type, errGet);
                }
            }

            // return unique key for the group map
            return [cm.sys_id, grd_rec[GuardiumAPI.GRP_COL_NAME]].join(':');
        },

        afterCM: function(cm, entry_map) {
            // remove any deleted datasources
            var sn_rec = new GlideRecord(GuardiumAPI.TABLE_GRP);
            sn_rec.addQuery(GuardiumAPI.GRP_COL_CM, '=', cm.sys_id);
            sn_rec.query();
            while (sn_rec.next()) {
                var _id = sn_rec.getValue(GuardiumAPI.GRP_COL_NAME);
                var key = '';
                if (_id) {
                    key = [cm.sys_id, _id].join(':');
                }
                if (!key || !entry_map[key]) {
                    try {
                        // entry was removed on Guardium, delete the ServiceNow record
                        sn_rec.setWorkflow(false);
                        sn_rec.deleteRecord();
                        this.deleted++;
                    } catch (errDel) {}
                }
            }
        },

        transform: function(datum, cm) {
            var rec = {};

            rec[GuardiumAPI.GRP_COL_APP_TYPE] = datum['appCriteria'] || 'ALL';
            rec[GuardiumAPI.GRP_COL_DB_TYPE] = datum['dsTypeCriteria'] || '';
            rec[GuardiumAPI.GRP_COL_GRP_TYPE] = datum['type'];
            rec[GuardiumAPI.GRP_COL_NAME] = datum["name"];
            rec[GuardiumAPI.GRP_COL_NAME_ORIG] = datum['name'];
            rec[GuardiumAPI.GRP_COL_CM] = cm.sys_id;

            return rec;
        },

        _initializeLookupCache: function() {
            this._lookupByType = {};

            var gr_map = new GlideRecord(GuardiumAPI.TABLE_DB_MAP);
            gr_map.query();
            while (gr_map.next()) {
                var db_type = gr_map.getValue('database_type');
                var class_name = gr_map.getValue('database_instance_class') || GuardiumAPI.TABLE_DB;

                this._lookupByType[db_type] = {
                    sys_id: gr_map.getValue('sys_id'),
                    db_instance_class: class_name,

                    database_name: {
                        grd_name: "Database Name",
                        sn_name: gr_map.getValue('database_name')
                    },
                    database_type: {
                        grd_name: "Datasource Type",
                        sn_name: db_type
                    },
                    service_name: {
                        grd_name: "Service Name",
                        sn_name: gr_map.getValue('service_name')
                    }
                };
            }
        },

        type: 'GuardiumProcessorDatasourceGroup'
    });]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-01-14 16:19:24</sys_created_on>
        <sys_id>3b90a2a987094950387c64280cbb35f7</sys_id>
        <sys_mod_count>43</sys_mod_count>
        <sys_name>GuardiumProcessorDatasourceGroup</sys_name>
        <sys_package display_value="IBM Guardium Data Protection" source="x_ibmrt_gdpva">400d30552fa0111049572f2ef699b65a</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="IBM Guardium Data Protection">400d30552fa0111049572f2ef699b65a</sys_scope>
        <sys_update_name>sys_script_include_3b90a2a987094950387c64280cbb35f7</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2022-11-05 17:54:41</sys_updated_on>
    </sys_script_include>
</record_update>
