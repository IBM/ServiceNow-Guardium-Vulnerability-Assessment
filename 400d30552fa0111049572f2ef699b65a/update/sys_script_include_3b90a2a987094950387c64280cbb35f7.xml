<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_ibmrt_gdpva.GuardiumProcessorDatasourceGroup</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>IBM Guardium database groups processor script</description>
        <name>GuardiumProcessorDatasourceGroup</name>
        <script><![CDATA[var GuardiumProcessorDatasourceGroup = Class.create();
GuardiumProcessorDatasourceGroup.APP_TYPES = {
    'Security Assessment': true,
    'ALL': true
};

GuardiumProcessorDatasourceGroup.prototype =
    Object.extendsObject(GuardiumProcessorBase, {

        beforeProcessReport: function() {
            this._initializeLookupCache();
        },

        beforeCM: function(cm, data) {
            this.gAPI = new GuardiumAPI(GuardiumAPI.getGlideRecordCM(cm.sys_id, true));
            this.gAPI.authenticate();
			
			this.customProperties = [];
			try {
				this.customProperties = this.gAPI.get('datasource_custom_prop').data;
				this.processCustomProperties(cm);
			} catch (e){
				GuardiumLog.error('Error fetching custom properties', this.type, e);
			}
        },

        processEntry: function(datum, cm) {
            var exists = false;
            var grd_rec = this.transform(datum, cm);

            // must pertain to VA
            if (!(grd_rec['application_type'] in GuardiumProcessorDatasourceGroup.APP_TYPES)) {
                this.skipped++;
                return;
            }

            // ignore the "All datasources" group
//             if ('DYNAMIC' == grd_rec['type'] && !grd_rec['datasource_type']) {
//                 this.skipped++;
//                 return;
//             }

            // find any previously loaded record ... if name changed in Guardium, we lose this connection
            var sn_rec = new GlideRecord(GuardiumAPI.TABLE_GRP);
            sn_rec.addQuery('name', '=', grd_rec['name']);
            sn_rec.addQuery('fqdn_cm', '=', cm.sys_id);
            sn_rec.setLimit(1);
            sn_rec.query();
            if (sn_rec.next()) {
                exists = true;
			}

            if (exists) {
                // is it the same?  if so, skip
                var skip = true;
                for (var prop in grd_rec) {
                    if (grd_rec[prop] != sn_rec.getValue(prop)) {
                        skip = false;
                        break;
                    }
                }
                if (skip) {
                    this.skipped++;
                    return [cm.sys_id, grd_rec['name']].join(':');
                }
            }

            if (!exists) {
				sn_rec.newRecord();
            }

            // Map incoming fields to destination fields
            for (var p in grd_rec) {
                sn_rec.setValue(p, grd_rec[p]);
            }

			// build conditions 
			// normally this is done via Bus.Rule, but because setWorkflow is false, we do it here manually
			sn_rec.setValue('conditions', GuardiumAPI.groupConditionBuilder(sn_rec));

			// Insert or Update
            var grp_sys_id = null;
            sn_rec.setWorkflow(false);
			sn_rec.setValue('action', 'synchronized');
            if (exists) {
                // Force update of original name
                sn_rec.setValue('group_name', grd_rec['name']);

                grp_sys_id = sn_rec.update();
                this.updated++;
            } else {
                // Insert new group
                grp_sys_id = sn_rec.insert();
                this.inserted++;
            }

            // If group type is STATIC, then create Data Source Group Map
            if ('STATIC' == grd_rec['type']) {
                try {
                    // Ask IBM Guardium what datasources are part of this group
                    var response = this.gAPI.get('datasource_group', {
                        groupName: grd_rec['group_name']
                    });

                    // Process the group members (Guardium DataSources)
                    if (response && response.data && response.data.length) {

                        // establish a cache to use later when looking for duplicate GlideRecords
                        var memberCache = {};
                        var member;
                        for (var n = 0; n < response.data.length; n++) {
                            member = response.data[n];

                            // find ServiceNow data-source entry that matches the Guardium DataSource
                            var sn_db = new GlideRecord(GuardiumAPI.TABLE_DB_GDP);
                            sn_db.addQuery('fqdn_cm', '=', cm.sys_id);
                            sn_db.addQuery('name', '=', member['name']);
                            sn_db.setLimit(1);
                            sn_db.query();
                            if (sn_db.next()) {
                                member.sys_id = sn_db.getUniqueValue();
                                memberCache[member.sys_id] = member;
                            }
                        }

                        // create or update static group members
                        var sn_map = new GlideRecord(GuardiumAPI.TABLE_GRP_MEMBER);
                        sn_map.addQuery('group', '=', grp_sys_id);
                        sn_map.query();
                        while (sn_map.next()) {
                            member = memberCache[sn_map.getValue('datasource')];
                            if (!member) {
                                // member was removed by IBM Guardium
                                sn_map.setWorkflow(false);
                                sn_map.deleteRecord();
                            } else {
                                member.processed = true;
                            }
                        }

                        // process any unprocessed entries
                        for (var db_sys_id in memberCache) {
                            if (!memberCache[db_sys_id].processed) {
                                // database was added by IBM Guardium
                                sn_map.initialize();
                                sn_map.setValue('group', grp_sys_id);
                                sn_map.setValue('datasource', db_sys_id);
                                sn_map.setWorkflow(false);
                                sn_map.insert();
                                memberCache[db_sys_id].processed = true;
                            }
                        }
                    }
                } catch (errGet) {
                    GuardiumLog.error('', this.type, errGet);
                }
            }

            // return unique key for the group map
            return [cm.sys_id, grd_rec['name']].join(':');
        },

        afterCM: function(cm, entry_map) {
			// remove any deleted datasource groups
            var sn_rec = new GlideRecord(GuardiumAPI.TABLE_GRP);
            sn_rec.addQuery('fqdn_cm', '=', cm.sys_id);
            sn_rec.query();
            while (sn_rec.next()) {
                var _id = sn_rec.getValue('name');
                var key = '';
                if (_id) {
                    key = [cm.sys_id, _id].join(':');
                }
                if (!key || !entry_map[key]) {
                    try {
                        // entry was removed on Guardium, delete the ServiceNow record
                        sn_rec.setWorkflow(false);
                        sn_rec.deleteRecord();
                        this.deleted++;
						GuardiumLog.debug(
							'Data Source Group deleted: '+  _id,
							this.type + '.afterCM'
						);
                    } catch (errDel) {}
                }
            }
        },

        transform: function(datum, cm) {
            var rec = {
				conditions: '',
				fqdn_cm: cm.sys_id,
				name: datum["name"],
				type: datum['type']
			};

            rec['group_name'] = rec['name'];
            rec['application_type'] = datum['appCriteria'] || 'ALL';
            rec['datasource_type'] = datum['dsTypeCriteria'] || '';
			rec['severity'] = (datum['severityCriteria'] || []).join(',');

			// flatten the custom properties
			var custom_fields = datum['customFields'] || {};
			var custom_properties = [];
			for (var pname in custom_fields) {
				custom_properties.push(pname + '=' + custom_fields[pname]);
			}
			rec['custom_properties'] = custom_properties.join(',');
			
            return rec;
        },

        _initializeLookupCache: function() {
            this._lookupByType = {};

            var gr_map = new GlideRecord(GuardiumAPI.TABLE_DB_MAP);
            gr_map.query();
            while (gr_map.next()) {
                var db_type = gr_map.getValue('database_type');
                var class_name = gr_map.getValue('database_instance_class') || 'cmdb_ci_db_instance';

                this._lookupByType[db_type] = {
                    sys_id: gr_map.getValue('sys_id'),
                    db_instance_class: class_name,

                    database_name: {
                        grd_name: "Database Name",
                        sn_name: gr_map.getValue('database_name')
                    },
                    database_type: {
                        grd_name: "Datasource Type",
                        sn_name: db_type
                    },
                    service_name: {
                        grd_name: "Service Name",
                        sn_name: gr_map.getValue('service_name')
                    }
                };
            }
        },
	
	processCustomProperties: function(cm) {
		// build property map so that deleted or renamed properties can be updated in ServiceNow
		var propertyMap = {};
		var sn_cp = new GlideRecord('x_ibmrt_gdpva_custom_property');
		sn_cp.addQuery('fqdn_cm', '=', cm.sys_id);
		sn_cp.query();
		while (sn_cp.next()) {
			// build a list of known properties
			propertyMap[sn_cp.getValue('property')] = 1;
		}

		// process all existing Guardium properties
		for (var i=0; i<this.customProperties.length; i++) {
			var cp = this.customProperties[i];
			for (var j=0; cp.values && j<cp.values.length; j++) {
				var property = cp.name + '=' + cp.values[j];
				if (!propertyMap[property]) {
					// create it
					var sn_new = new GlideRecord('x_ibmrt_gdpva_custom_property');
					sn_new.setValue('property', property);
					sn_new.setValue('fqdn_cm', cm.sys_id);
					sn_new.insert();
				}
				propertyMap[property] = 2;
			}
		}
		
		// delete all ServiceNow properties no longer in Guardium
		for (var prop in propertyMap) {
			if (1 == propertyMap[prop]) {
				var sn_del = new GlideRecord('x_ibmrt_gdpva_custom_property');
				sn_del.deleteRecord();
			}
		}
	},

        type: 'GuardiumProcessorDatasourceGroup'
    });]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-01-14 16:19:24</sys_created_on>
        <sys_id>3b90a2a987094950387c64280cbb35f7</sys_id>
        <sys_mod_count>53</sys_mod_count>
        <sys_name>GuardiumProcessorDatasourceGroup</sys_name>
        <sys_package display_value="IBM Guardium Data Protection" source="x_ibmrt_gdpva">400d30552fa0111049572f2ef699b65a</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="IBM Guardium Data Protection">400d30552fa0111049572f2ef699b65a</sys_scope>
        <sys_update_name>sys_script_include_3b90a2a987094950387c64280cbb35f7</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2023-03-16 16:31:22</sys_updated_on>
    </sys_script_include>
</record_update>
