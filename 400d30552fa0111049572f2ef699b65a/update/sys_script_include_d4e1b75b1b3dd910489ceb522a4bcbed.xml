<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_ibmrt_gdpva.GuardiumRunIntegration</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>Finds and runs specified integration</description>
        <name>GuardiumRunIntegration</name>
        <script><![CDATA[var GuardiumRunIntegration = {
    THREE_MINUTES: 180000,
    MAX_ATTEMPTS: 200, // 20 hours of 3 minute intervals

    integrations: {
        "asset:managed_unit": true,
        "asset:database": true,
        "asset:database_group": true,
        "test_result": true,
        "vulnerable_item": true,
        "vulnerability:assessment": true,
        "vulnerability:exception": true,
        "vulnerability:third_party_test": false
    },

    // Find the integration specified by type:subtype and run with parameters
    byType: function(integType, parameters) {
        var types = integType.split(":");
        var gr_integ = new GlideRecord(GuardiumAPI.TABLE_VUL_INTEG);
        gr_integ.addQuery("type", "=", types[0]);
        gr_integ.addQuery("sub_type", "=", types[1] || '');
        gr_integ.addActiveQuery();
        gr_integ.setLimit(1);
        gr_integ.query();
        if (gr_integ.next()) {
            return GuardiumRunIntegration.queue(gr_integ, parameters);
        } else {
            throw new Error("Invalid integration reference: " + integType);
        }
    },

    // Run the specified integration with parameters
    byRef: function(integSysId, parameters) {
        var gr_integ = new GlideRecord(GuardiumAPI.TABLE_VUL_INTEG);
        if (gr_integ.get(integSysId)) {
            return GuardiumRunIntegration.queue(gr_integ, parameters);
        } else {
            throw new Error("Invalid integration reference: " + integSysId);
        }
    },

    // Queue up integration to be run
    queue: function(gr_integ, parameters) {
        var name = gr_integ.getDisplayValue(gr_integ.getDisplayName());
        parameters = GuardiumRunIntegration.checkParameters(parameters, true);
        if (GuardiumRunIntegration._hasOutstandingDependencies(gr_integ, parameters)) {
            try {
                // Check number of attempts
                var count = (parameters['count'] - 0 || 0) + 1;
                if (count >= GuardiumRunIntegration.MAX_ATTEMPTS) {
                    GuardiumLog.warn(
                        'Queue integration "' + name + '" too many attempts. Cancelling.',
                        GuardiumRunIntegration.type
                    );
                    GuardiumRunIntegration.failAndComplete(gr_integ, parameters);
                    return;
                }
                parameters['count'] = count;

                // Queue up the event for later processing
                var dtCheckLater = new GlideDateTime();
                dtCheckLater.add(GuardiumRunIntegration.THREE_MINUTES); // check again in 3 minutes
                GuardiumLog.debug(
                    'Queue integration "' + name + '" to try again at ' + dtCheckLater.toString(),
                    GuardiumRunIntegration.type
                );

                gs.eventQueueScheduled(
                    'x_ibmrt_gdpva.QueueDataImport',
                    gr_integ,
                    name,
                    JSON.stringify(parameters),
                    dtCheckLater
                );
            } catch (e) {
                GuardiumLog.error('', GuardiumRunIntegration.type, e);
            }
            return;
        }

        // Dependencies have been resolved, run it!
        GuardiumRunIntegration._run(gr_integ, parameters);
    },

    _run: function(gr_integ, parameters) {
        var name = gr_integ.getDisplayValue(gr_integ.getDisplayName());
        try {
            // since we cannot trigger a scheduled job from this scope
            // we must create a new run record and cause VR to fire
            var gr_vi_run = new GlideRecord("sn_vul_integration_run");
            gr_vi_run.initialize();
            if (parameters) {
                gr_vi_run.setValue("parameters", JSON.stringify(parameters));
            }
            gr_vi_run.setValue("integration", gr_integ.sys_id);
            gr_vi_run.setValue("implementation", gr_integ.getValue("instance"));
            (new sn_vul.VulnerabilityIntegrationUtils()).startIntegrationRun(gr_vi_run);
            GuardiumLog.debug(
                'Start integration run for "' + name + '"',
                GuardiumRunIntegration.type
            );
        } catch (e) {
            GuardiumLog.error('', GuardiumRunIntegration.type, e);
            throw e;
        }
        return true;
    },

    // Does this integration have dependencies?
    _hasOutstandingDependencies: function(gr_integ, parameters) {
        var gr_sync = GuardiumRunIntegration._getSyncRecord(parameters);
        if (gr_sync) {
            var completed_integrations = gr_sync.getValue('completed_integrations');
            var full_sync = '1' == gr_sync.getValue('full_sync');
            // get all dependency records and check if they have finished
            var gr_dep = new GlideRecord(GuardiumAPI.TABLE_DEP);
            gr_dep.addQuery('integration', '=', gr_integ.getUniqueValue());
            gr_dep.query();
            while (gr_dep.next()) {
                var dep_sys_id = gr_dep.getValue('dependency');
                var full_sync_only = '1' == gr_dep.getValue('full_sync_only');

                // if not doing full_sync, don't check for full_sync_only deps
                if (full_sync || !full_sync_only) {
                    if (!completed_integrations.includes(dep_sys_id)) {
                        // This dependency has not completed yet
                        GuardiumLog.debug(
                            '"' +
                            gr_integ.getDisplayValue(gr_integ.getDisplayName()) +
                            '" is waiting on dependency "' +
                            gr_dep.getDisplayValue('dependency') +
                            '"\n' + 
							[gr_integ.getUniqueValue(), dep_sys_id, completed_integrations].join('\n')
							, this.type
                        );
                        return true;
                    }
                }
            }
        }
        return false;
    },

    // Return the sync record referenced by the parameters
    _getSyncRecord: function(parameters) {
        var sync_sys_id = GuardiumRunIntegration.getValueFromParameters(parameters, 'sync_sys_id');
        if (sync_sys_id) {
            var gr_sync = new GlideRecord(GuardiumAPI.TABLE_CM_SYNC);
            if (gr_sync.get(sync_sys_id)) {
                return gr_sync;
            }
        }
        GuardiumLog.warn("Invalid parameters", this.type, parameters);
        return null;
    },

    // Called by a business rule when sn_vul_integration_run is complete
    complete: function(gr_integ_run) {
        if (!gr_integ_run) {
            throw new Error("Invalid integration run record");
        }

        // notify sync manager
        var gr_sync = GuardiumRunIntegration._getSyncRecord(gr_integ_run.getValue('parameters'));
        if (gr_sync) {
            // sys_id of completed
            gr_sync.setValue(
                'completed_integrations',
                gr_integ_run.getValue('integration') + ';' + gr_sync.getValue('completed_integrations')
            );

            // number of completed
            gr_sync.setValue('completed', 1 + (gr_sync.getValue('completed') - 0));

            if ('success' == gr_integ_run.getValue('substate')) {
                // number of successful
                gr_sync.setValue('successful', 1 + (gr_sync.getValue('successful') - 0));
            }

            if (failed) {
                gr_integ_run.setValue('substate', 'failed');
            }
            gr_sync.update();
        }
    },

    // Called by a business rule when sn_vul_integration_run is complete
    failAndComplete: function(gr_integ, parameters) {
        if (!gr_integ) {
            throw new Error("Invalid integration record");
        }

        // notify sync manager
        var gr_sync = GuardiumRunIntegration._getSyncRecord(parameters);
        if (gr_sync) {
            // sys_id of completed
            gr_sync.setValue(
                'completed_integrations',
                gr_integ.getUniqueValue() + ';' + gr_sync.getValue('completed_integrations')
            );

            // number of completed
            gr_sync.setValue('completed', 1 + (gr_sync.getValue('completed') - 0));

            // update
            gr_sync.update();
        }
    },

    getValueFromParameters: function(parameters, key) {
        return GuardiumRunIntegration.checkParameters(parameters)[key] || '';
    },

    checkParameters: function(parameters, errorIfNull) {
        if ('string' == typeof(parameters)) {
            try {
                parameters = JSON.parse(parameters);
            } catch (e) {
				parameters = {};
                GuardiumLog.warn(
                    'Could not parse parameters "' + parameters + '"',
                    GuardiumRunIntegration.type
                );
            }
        }

        if (errorIfNull && !parameters) {
            throw new Error('Parameters are null');
        }
        return parameters || {};
    },

    type: 'GuardiumRunIntegration'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2022-09-13 11:52:56</sys_created_on>
        <sys_id>d4e1b75b1b3dd910489ceb522a4bcbed</sys_id>
        <sys_mod_count>33</sys_mod_count>
        <sys_name>GuardiumRunIntegration</sys_name>
        <sys_package display_value="IBM Guardium Vulnerability Assessment" source="x_ibmrt_gdpva">400d30552fa0111049572f2ef699b65a</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="IBM Guardium Vulnerability Assessment">400d30552fa0111049572f2ef699b65a</sys_scope>
        <sys_update_name>sys_script_include_d4e1b75b1b3dd910489ceb522a4bcbed</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2022-10-20 01:04:41</sys_updated_on>
    </sys_script_include>
</record_update>
